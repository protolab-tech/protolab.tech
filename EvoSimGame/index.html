<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="EvoSimGame - Interactive evolutionary cell simulation. Watch cells evolve, adapt, and survive in a dynamic environment with mutation, predation, and environmental pressures." />
  <meta name="keywords" content="evolution simulation, cellular automata, biology game, genetic algorithm, mutation, natural selection, interactive simulation" />
  <meta name="author" content="Protolab" />
  <meta name="robots" content="index, follow" />
  <link rel="canonical" href="https://protolab.tech/EvoSimGame/" />
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="EvoSimGame - Interactive Evolution Simulation" />
  <meta property="og:description" content="Watch cells evolve, adapt, and survive in a dynamic environment with mutation, predation, and environmental pressures." />
  <meta property="og:url" content="https://protolab.tech/EvoSimGame/" />
  <meta property="og:site_name" content="Protolab" />
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="EvoSimGame - Interactive Evolution Simulation" />
  <meta name="twitter:description" content="Watch cells evolve, adapt, and survive in a dynamic environment with mutation, predation, and environmental pressures." />
  
  <title>EvoSimGame - Interactive Evolution Simulation | Protolab</title>
  <link rel="icon" type="image/svg+xml" href="/assets/images/logo.svg" />
  
  <!-- Preload critical assets -->
  <link rel="preload" href="assets/css/style.css" as="style">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <!-- Stylesheets -->
  <link rel="stylesheet" href="assets/css/style.css">
  <link rel="stylesheet" href="assets/css/enhanced-select.css">
  <link rel="stylesheet" href="assets/css/stats-panel.css">
  
  <!-- Configuration -->
  <script src="assets/js/config.js"></script>
  
  <!-- SQL.js for evolution database -->
  <script src="https://sql.js.org/dist/sql-wasm.js"></script>
  
  <!-- Security headers -->
  <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
</head>
<body>
  <!-- Skip navigation for accessibility -->
  <a href="#main-content" class="sr-only sr-only-focusable">Skip to main content</a>
  
  <header role="banner" class="evosim-header">
    <div class="evosim-header-container">
      <div class="evosim-header-title">
        <h1>EvoSimGame</h1>
        <span class="evosim-subtitle">Interactive Evolution Simulation</span>
      </div>
      <a href="/" class="evosim-header-logo">
        <span class="evosim-header-brand">protolab.tech</span>
      </a>
    </div>
  </header>

<main id="main-content" role="main" class="evosim-main">
<div id="app">
  <aside id="sidebar">
    <div class="sidebar-toggle">
      <button id="sidebarToggle" class="toggle-btn" aria-label="Toggle sidebar">
        <span class="toggle-icon">‚Äπ</span>
      </button>
    </div>
    
    <div class="card collapsible-card">
      <div class="card-header" data-target="environment-content">
        <h2>Environment</h2>
        <span class="collapse-icon">‚àí</span>
      </div>
      <div class="card-content" id="environment-content">

      <label>
        <span>Resource Density</span>
        <span class="val" id="vResources">600</span>
      </label>
      <input id="resources" type="range" min="0" max="1000" step="20" value="600" aria-label="Resource Density"/>

      <label>
        <span>Temperature</span>
        <span class="val" id="vTemp">50</span>
      </label>
      <input id="temp" type="range" min="0" max="100" step="1" value="50" aria-label="Temperature"/>

      <div class="tempBarWrap">
        <div class="tempBar">
          <div class="tempZone"></div>
          <div class="tempMarker" id="tempMarker"></div>
        </div>
        <div class="tiny temp-bar-description">
          Gradient shows cold‚Üíhot. Green zone is optimal (~35‚Äì65). Cells take damage if their resistance doesn't match current temperature.
        </div>
      </div>

      <label>
        <span>Stability</span>
        <span class="val" id="vStability">60</span>
      </label>
      <input id="stability" type="range" min="0" max="100" step="1" value="60" aria-label="Stability"/>

      <label>
        <span>Radiation Level</span>
        <span class="val" id="vRad">2</span>
      </label>
      <input id="rad" type="range" min="0" max="8" step="1" value="2" aria-label="Radiation Level"/>

        <div id="legend" class="tiny">
          <div class="legendLine"><span>Radiation 0</span><span>rare mutations</span></div>
          <div class="legendLine"><span>Radiation 6-7</span><span class="warn">high mutation rate</span></div>
          <div class="legendLine"><span>Radiation 8</span><span class="danger">instant death / chaos</span></div>
        </div>
      </div>
    </div>


    <div class="card collapsible-card genome-card">
      <div class="card-header" data-target="genome-content">
        <h2>Initial Seed (Genome 0‚Äì7)</h2>
        <span class="collapse-icon">‚àí</span>
      </div>
      <div class="card-content" id="genome-content">

      <h3>Fertility (shape)</h3>
      <label><span>Fertility</span><span class="val" id="vFert">3</span></label>
      <input id="seedFert" type="range" min="0" max="7" step="1" value="3" aria-label="Fertility"/>

      <h3>Temperature Resistance (color)</h3>
      <label><span>Resistance</span><span class="val" id="vRes">3</span></label>
      <input id="seedRes" type="range" min="0" max="7" step="1" value="3" aria-label="Temperature Resistance"/>

      <h3>Energy Efficiency (size)</h3>
      <label><span>Efficiency</span><span class="val" id="vEff">4</span></label>
      <input id="seedEff" type="range" min="0" max="7" step="1" value="4" aria-label="Energy Efficiency"/>

      <h3>Aggressivity (brightness)</h3>
      <label><span>Aggressivity</span><span class="val" id="vAgg">2</span></label>
      <input id="seedAgg" type="range" min="0" max="7" step="1" value="2" aria-label="Aggressivity"/>

      <h3>Infectivity (plague)</h3>
      <label><span>Infectivity</span><span class="val" id="vInf">0</span></label>
      <input id="seedInf" type="range" min="0" max="7" step="1" value="0" aria-label="Infectivity"/>

      <div class="inject-button-container">
        <button class="btn" id="inject">Inject Cell / Restart World</button>
      </div>

        <div class="tiny visual-mapping-description">
          Visual mapping: Fertility‚Üíshape (0-15), Resistance‚Üícolor (blue‚Üíred, 0-15), Efficiency‚Üísize (0-15), Aggressivity‚Üíglow (0-15), Infectivity‚Üíinfect radius + death timer if &gt;5.
        </div>
      </div>
    </div>

    <div class="card collapsible-card map-zones-card">
      <div class="card-header" data-target="map-zones-content">
        <h2>Map Zones</h2>
        <span class="collapse-icon">‚àí</span>
      </div>
      <div class="card-content" id="map-zones-content">
        <div class="scatter-control">
          <label>
            <span>Grid Size</span>
            <span class="val" id="vScatter">1x1</span>
          </label>
          <select id="scatter" aria-label="Grid Size">
            <option value="1">1x1 (No divisions)</option>
            <option value="2">2x2 (4 zones)</option>
            <option value="3">3x3 (9 zones)</option>
            <option value="4">4x4 (16 zones)</option>
            <option value="5">5x5 (25 zones)</option>
            <option value="6">6x6 (36 zones)</option>
            <option value="7">7x7 (49 zones)</option>
            <option value="8">8x8 (64 zones)</option>
            <option value="9">9x9 (81 zones)</option>
            <option value="10">10x10 (100 zones)</option>
          </select>
        </div>
        <div class="scatter-control variance-control" id="varianceControl">
          <label>
            <span>Variance Delta (%)</span>
            <span class="val" id="vVariance">20</span>
          </label>
          <input id="variance" type="range" min="5" max="50" step="5" value="20" aria-label="Variance Percentage"/>
        </div>
        <div class="tiny zone-description">
          Divisions create fractal zones with varying parameters. Variance limits max difference between zones.
        </div>
      </div>
    </div>

    <div class="card collapsible-card rules-card">
      <div class="card-header" data-target="rules-content">
        <h2>Rules Summary</h2>
        <span class="collapse-icon collapsed">+</span>
      </div>
      <div class="card-content collapsed" id="rules-content">
        <ul class="rules-list">
          <li>Food spawns with Available Resources.</li>
          <li>Energy drains over time (lower drain with high Efficiency).</li>
          <li>Temperature mismatch drains health.</li>
          <li>Radiation mutates traits (or kills at level 8).</li>
          <li>Reproduction splits when energy is high; offspring inherits ¬± mutation.</li>
          <li>Aggressive cells prey on smaller ones on contact; predator gains energy.</li>
          <li>Infectivity &gt;5 starts a timer and spreads on proximity; dense populations trigger plague faster.</li>
        </ul>
      </div>
    </div>
  </aside>

  <main id="worldWrap">
    <!-- Enhanced HUD -->
    <div id="hud">
      <div class="pill"><b>Cells</b> <span id="hudCells">0</span></div>
      <div class="pill"><b>Food</b> <span id="hudFood">0</span></div>
      <div class="pill"><b>Gen</b> <span id="hudGeneration">0</span></div>
      <div class="pill"><b>Species</b> <span id="hudSpecies">0</span></div>
      <div class="pill"><b>Fitness</b> <span id="hudFitness">0</span></div>
      <div class="pill"><b>Plague</b> <span id="hudPlague">off</span></div>
    </div>
    
    <!-- Evolution Events -->
    <div id="evolutionEvents" class="evolution-events"></div>
    
    <!-- Map Controls Overlay -->
    <div id="mapControls" class="map-overlay">
      <div class="control-group">
        <button id="zoomIn" class="control-btn" title="Zoom In">+</button>
        <button id="zoomOut" class="control-btn" title="Zoom Out">‚àí</button>
        <button id="resetZoom" class="control-btn" title="Reset View">‚åÇ</button>
        <button id="pauseBtn" class="control-btn" title="Pause/Resume Simulation">‚è∏Ô∏è</button>
      </div>
      <div class="zoom-display">
        <span id="vZoom">1.0x</span>
      </div>
    </div>
    
    
    <!-- Minimap -->
    <div id="minimap" class="minimap">
      <div class="panel-header">
        <span class="panel-title">Map</span>
        <button class="panel-toggle" id="minimapToggle" title="Toggle Minimap">‚àí</button>
      </div>
      <div class="panel-content" id="minimapContent">
        <canvas id="minimapCanvas" width="150" height="150"></canvas>
        <div id="viewportIndicator" class="viewport-indicator"></div>
      </div>
    </div>
    
    <!-- Ecosystem Stats Panel -->
    <div id="ecosystemStats" class="ecosystem-stats">
      <div class="panel-header">
        <span class="panel-title">Ecosystem Stats</span>
        <button class="panel-toggle" id="statsToggle" title="Toggle Stats">‚àí</button>
      </div>
      <div class="panel-content" id="statsContent">
        <div class="stats-grid">
        <div class="stat-item">
          <span class="stat-label">Active Cells</span>
          <span class="stat-value" id="statActiveCells">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Available Food</span>
          <span class="stat-value" id="statAvailableFood">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Infected Cells</span>
          <span class="stat-value" id="statInfectedCells">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Total Born</span>
          <span class="stat-value" id="statTotalBorn">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Max Generation</span>
          <span class="stat-value" id="statMaxGeneration">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">Avg Lifespan</span>
          <span class="stat-value" id="statAvgLifespan">0.0s</span>
        </div>
        </div>
        
        <!-- Population Graph Toggle -->
        <div class="graph-controls">
          <button id="togglePopGraph" class="graph-toggle-btn">üìä Show Population Graph</button>
        </div>
        
        <!-- Population Graph Container -->
        <div id="populationGraph" class="population-graph" style="display: none;">
          <canvas id="popGraphCanvas" width="300" height="150"></canvas>
        </div>
      </div>
    </div>
    
    <!-- Main Canvas -->
    <canvas id="c"></canvas>
    
    <!-- Stats Summary Modal -->
    <div id="statsSummaryModal" class="stats-modal" style="display: none;">
      <div class="modal-content">
        <div class="modal-header">
          <h2>üìä Simulation Summary</h2>
          <button id="closeStatsModal" class="close-btn">√ó</button>
        </div>
        <div class="modal-body">
          <div class="summary-grid">
            <div class="summary-item">
              <span class="summary-label">Total Runtime</span>
              <span class="summary-value" id="summaryRuntime">0s</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Peak Population</span>
              <span class="summary-value" id="summaryPeakPop">0</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Total Births</span>
              <span class="summary-value" id="summaryTotalBirths">0</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Total Deaths</span>
              <span class="summary-value" id="summaryTotalDeaths">0</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Max Generation Reached</span>
              <span class="summary-value" id="summaryMaxGen">0</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Average Lifespan</span>
              <span class="summary-value" id="summaryAvgLifespan">0.0s</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Extinction Events</span>
              <span class="summary-value" id="summaryExtinctions">0</span>
            </div>
            <div class="summary-item">
              <span class="summary-label">Final Population</span>
              <span class="summary-value" id="summaryFinalPop">0</span>
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button id="resumeBtn" class="modal-btn primary">‚ñ∂Ô∏è Resume</button>
          <button id="restartBtn" class="modal-btn secondary">üîÑ Restart</button>
        </div>
      </div>
    </div>
  </main>
</div>

<footer role="contentinfo" class="evosim-footer">
  <div class="evosim-footer-container">
    <div class="evosim-footer-logo">
      <a href="/">
        <img src="/assets/images/logo.svg" alt="protolab.tech" width="80" height="24" loading="lazy" />
      </a>
    </div>
    <div class="evosim-contact-info">
      <a href="mailto:info@protolab.tech">info@protolab.tech</a>
    </div>
    <div class="evosim-social-links">
      <a href="https://instagram.com/protolab.tech" target="_blank" rel="noopener" aria-label="Instagram">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/>
        </svg>
      </a>
      <a href="https://tiktok.com/@protolab.tech" target="_blank" rel="noopener" aria-label="TikTok">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
          <path d="M19.59 6.69a4.83 4.83 0 0 1-3.77-4.25V2h-3.45v13.67a2.89 2.89 0 0 1-5.2 1.74 2.89 2.89 0 0 1 2.31-4.64 2.93 2.93 0 0 1 .88.13V9.4a6.84 6.84 0 0 0-1-.05A6.33 6.33 0 0 0 5 20.1a6.34 6.34 0 0 0 10.86-4.43v-7a8.16 8.16 0 0 0 4.77 1.52v-3.4a4.85 4.85 0 0 1-1-.1z"/>
        </svg>
      </a>
    </div>
  </div>
</footer>
</main>


<!-- Structured Data -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "WebApplication",
  "name": "EvoSimGame",
  "description": "Interactive evolutionary cell simulation game",
  "url": "https://protolab.tech/EvoSimGame/",
  "applicationCategory": "Game",
  "operatingSystem": "Web Browser",
  "author": {
    "@type": "Organization",
    "name": "Protolab",
    "url": "https://protolab.tech/"
  },
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "EUR"
  }
}
</script>

<script src="/assets/js/monitoring.js" defer></script>
<script>
(() => {
  // ---------- Utilities ----------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (a=0, b=1) => a + Math.random()*(b-a);
  const irand = (a, b) => (a + Math.floor(Math.random()*(b-a+1)));
  const hypot2 = (dx, dy) => dx*dx + dy*dy;

  function hsl(h, s, l, a=1){
    return `hsla(${h},${s}%,${l}%,${a})`;
  }

  function mixRGB(c1, c2, t){
    // c1/c2: [r,g,b]
    return [
      Math.round(lerp(c1[0], c2[0], t)),
      Math.round(lerp(c1[1], c2[1], t)),
      Math.round(lerp(c1[2], c2[2], t))
    ];
  }

  // Blue(0) -> Red(7)
  const COLD = [37, 99, 235];   // ~#2563eb
  const HOT  = [239, 68, 68];   // ~#ef4444
  function resistanceColor(level, brightness01=0.7){
    // Use config scaling: 0-7 genome * 2.0 = 0-14 effective range
    const effectiveLevel = level * EvoSimConfig.genetics.resistanceColorScale;
    const t = clamp(effectiveLevel/14, 0, 1);
    const [r,g,b] = mixRGB(COLD, HOT, t);
    // brightness01 modulates luminance; keep saturation-ish
    const br = lerp(0.35, 1.05, brightness01);
    return `rgba(${Math.round(r*br)},${Math.round(g*br)},${Math.round(b*br)},1)`;
  }

  // ---------- DOM ----------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  // ---------- ZOOM AND VIEWPORT ----------
  let zoomLevel = 1.0; // Default starting zoom at 1x
  let minZoom = 0.1; // Will be calculated based on viewport size
  let maxZoom = 5.0;
  let viewportX = 0;
  let viewportY = 0;
  let isDragging = false;
  let lastMouseX = 0;
  let lastMouseY = 0;
  
  // Touch support variables
  let touches = [];
  let lastTouchDistance = 0;
  let isPinching = false;

  const el = {
    resources: document.getElementById('resources'),
    temp: document.getElementById('temp'),
    stability: document.getElementById('stability'),
    rad: document.getElementById('rad'),
    seedFert: document.getElementById('seedFert'),
    seedRes: document.getElementById('seedRes'),
    seedEff: document.getElementById('seedEff'),
    seedAgg: document.getElementById('seedAgg'),
    seedInf: document.getElementById('seedInf'),
    inject: document.getElementById('inject'),

    vResources: document.getElementById('vResources'),
    vTemp: document.getElementById('vTemp'),
    vStability: document.getElementById('vStability'),
    vRad: document.getElementById('vRad'),

    vFert: document.getElementById('vFert'),
    vRes: document.getElementById('vRes'),
    vEff: document.getElementById('vEff'),
    vAgg: document.getElementById('vAgg'),
    vInf: document.getElementById('vInf'),

    tempMarker: document.getElementById('tempMarker'),

    hudCells: document.getElementById('hudCells'),
    hudFood: document.getElementById('hudFood'),
    hudMut: document.getElementById('hudMut'),
    hudPlague: document.getElementById('hudPlague'),
    hudGeneration: document.getElementById('hudGeneration'),
    hudSpecies: document.getElementById('hudSpecies'),
    hudFitness: document.getElementById('hudFitness'),
    evolutionEvents: document.getElementById('evolutionEvents'),

    // Ecosystem Stats Panel
    statActiveCells: document.getElementById('statActiveCells'),
    statAvailableFood: document.getElementById('statAvailableFood'),
    statInfectedCells: document.getElementById('statInfectedCells'),
    statTotalBorn: document.getElementById('statTotalBorn'),
    statMaxGeneration: document.getElementById('statMaxGeneration'),
    statAvgLifespan: document.getElementById('statAvgLifespan'),

    // New controls
    vZoom: document.getElementById('vZoom'),
    zoomIn: document.getElementById('zoomIn'),
    zoomOut: document.getElementById('zoomOut'),
    resetZoom: document.getElementById('resetZoom'),
    pauseBtn: document.getElementById('pauseBtn'),
    scatter: document.getElementById('scatter'),
    vScatter: document.getElementById('vScatter'),
    variance: document.getElementById('variance'),
    vVariance: document.getElementById('vVariance'),
    varianceControl: document.getElementById('varianceControl'),
    minimapCanvas: document.getElementById('minimapCanvas'),
    viewportIndicator: document.getElementById('viewportIndicator'),
    
    // Panel toggles
    minimapToggle: document.getElementById('minimapToggle'),
    statsToggle: document.getElementById('statsToggle'),
    minimapContent: document.getElementById('minimapContent'),
    statsContent: document.getElementById('statsContent'),
    
    // Population graph
    togglePopGraph: document.getElementById('togglePopGraph'),
    populationGraph: document.getElementById('populationGraph'),
    popGraphCanvas: document.getElementById('popGraphCanvas'),
    
    // Stats summary modal
    statsSummaryModal: document.getElementById('statsSummaryModal'),
    closeStatsModal: document.getElementById('closeStatsModal'),
    resumeBtn: document.getElementById('resumeBtn'),
    restartBtn: document.getElementById('restartBtn'),
    summaryRuntime: document.getElementById('summaryRuntime'),
    summaryPeakPop: document.getElementById('summaryPeakPop'),
    summaryTotalBirths: document.getElementById('summaryTotalBirths'),
    summaryTotalDeaths: document.getElementById('summaryTotalDeaths'),
    summaryMaxGen: document.getElementById('summaryMaxGen'),
    summaryAvgLifespan: document.getElementById('summaryAvgLifespan'),
    summaryExtinctions: document.getElementById('summaryExtinctions'),
    summaryFinalPop: document.getElementById('summaryFinalPop'),
  };

  function syncLabels(){
    el.vResources.textContent = el.resources.value;
    el.vTemp.textContent = el.temp.value;
    el.vStability.textContent = el.stability.value;
    el.vRad.textContent = el.rad.value;

    el.vFert.textContent = el.seedFert.value;
    el.vRes.textContent  = el.seedRes.value;
    el.vEff.textContent  = el.seedEff.value;
    el.vAgg.textContent  = el.seedAgg.value;
    el.vInf.textContent  = el.seedInf.value;

    el.vZoom.textContent = zoomLevel.toFixed(1) + 'x';
    
    // Update scatter display with grid size
    const scatterValue = Number(el.scatter.value);
    el.vScatter.textContent = `${scatterValue}x${scatterValue}`;
    
    el.vVariance.textContent = el.variance.value;

    const t = Number(el.temp.value);
    el.tempMarker.style.left = `calc(${t}% - 1px)`;

    // Show/hide scatter variance control (reuse scatterValue)
    if (scatterValue > 1) {
      el.varianceControl.style.display = 'block';
      el.varianceControl.classList.remove('variance-control');
    } else {
      el.varianceControl.style.display = 'none';
      el.varianceControl.classList.add('variance-control');
    }
  }
  ['input','change'].forEach(ev=>{
    el.resources.addEventListener(ev, syncLabels);
    el.temp.addEventListener(ev, syncLabels);
    el.stability.addEventListener(ev, syncLabels);
    el.rad.addEventListener(ev, syncLabels);
    el.seedFert.addEventListener(ev, syncLabels);
    el.seedRes.addEventListener(ev, syncLabels);
    el.seedEff.addEventListener(ev, syncLabels);
    el.seedAgg.addEventListener(ev, syncLabels);
    el.seedInf.addEventListener(ev, syncLabels);
    el.variance.addEventListener(ev, syncLabels);
  });
  
  // Scatter uses 'change' event for select dropdown
  el.scatter.addEventListener('change', () => {
    syncLabels();
    // Regenerate parameter map when scatter changes
    generateParameterMap();
  });
  
  // Initialize UI controls with config.js defaults
  // Settings cache using localStorage
  function saveSettingsToCache() {
    const settings = {
      // Environment settings
      resources: el.resources.value,
      temperature: el.temp.value,
      stability: el.stability.value,
      radiation: el.rad.value,
      
      // Genome settings
      fertility: el.seedFert.value,
      resistance: el.seedRes.value,
      efficiency: el.seedEff.value,
      aggressivity: el.seedAgg.value,
      infectivity: el.seedInf.value,
      
      // Map settings
      scatter: el.scatter.value,
      variance: el.variance.value,
      
      // Sidebar state
      sidebarCollapsed: sidebar.classList.contains('collapsed'),
      
      // Card states
      environmentCollapsed: document.getElementById('environment-content').classList.contains('collapsed'),
      genomeCollapsed: document.getElementById('genome-content').classList.contains('collapsed'),
      mapZonesCollapsed: document.getElementById('map-zones-content').classList.contains('collapsed'),
      rulesCollapsed: document.getElementById('rules-content').classList.contains('collapsed'),
      
      // Panel states
      minimapCollapsed: el.minimapContent.classList.contains('collapsed'),
      statsCollapsed: el.statsContent.classList.contains('collapsed')
    };
    
    try {
      localStorage.setItem('evosim-settings', JSON.stringify(settings));
      console.log('Settings saved to cache');
    } catch (error) {
      console.warn('Failed to save settings to cache:', error);
    }
  }
  
  function loadSettingsFromCache() {
    try {
      const cached = localStorage.getItem('evosim-settings');
      if (!cached) return false;
      
      const settings = JSON.parse(cached);
      console.log('Loading cached settings:', settings);
      
      // Apply environment settings
      if (settings.resources !== undefined) el.resources.value = settings.resources;
      if (settings.temperature !== undefined) el.temp.value = settings.temperature;
      if (settings.stability !== undefined) el.stability.value = settings.stability;
      if (settings.radiation !== undefined) el.rad.value = settings.radiation;
      
      // Apply genome settings
      if (settings.fertility !== undefined) el.seedFert.value = settings.fertility;
      if (settings.resistance !== undefined) el.seedRes.value = settings.resistance;
      if (settings.efficiency !== undefined) el.seedEff.value = settings.efficiency;
      if (settings.aggressivity !== undefined) el.seedAgg.value = settings.aggressivity;
      if (settings.infectivity !== undefined) el.seedInf.value = settings.infectivity;
      
      // Apply map settings
      if (settings.scatter !== undefined) el.scatter.value = settings.scatter;
      if (settings.variance !== undefined) el.variance.value = settings.variance;
      
      // Apply UI states
      if (settings.sidebarCollapsed) sidebar.classList.add('collapsed');
      
      // Apply card states
      const cardStates = [
        { id: 'environment-content', collapsed: settings.environmentCollapsed },
        { id: 'genome-content', collapsed: settings.genomeCollapsed },
        { id: 'map-zones-content', collapsed: settings.mapZonesCollapsed },
        { id: 'rules-content', collapsed: settings.rulesCollapsed }
      ];
      
      cardStates.forEach(({ id, collapsed }) => {
        const content = document.getElementById(id);
        const header = content?.previousElementSibling;
        const icon = header?.querySelector('.collapse-icon');
        
        if (content && collapsed) {
          content.classList.add('collapsed');
          if (icon) {
            icon.classList.add('collapsed');
            icon.textContent = '+';
          }
        }
      });
      
      // Apply panel states
      if (settings.minimapCollapsed) {
        el.minimapContent.classList.add('collapsed');
        el.minimapToggle.textContent = '+';
      }
      
      if (settings.statsCollapsed) {
        el.statsContent.classList.add('collapsed');
        el.statsToggle.textContent = '+';
      }
      
      // Update all labels to reflect loaded values
      syncLabels();
      
      return true;
    } catch (error) {
      console.warn('Failed to load settings from cache:', error);
      return false;
    }
  }

  function initializeUIFromConfig() {
    const { controls } = EvoSimConfig;
    
    // Environment controls
    el.resources.min = controls.resources.min;
    el.resources.max = controls.resources.max;
    el.resources.step = controls.resources.step;
    el.resources.value = controls.resources.default;
    
    el.temp.min = controls.temperature.min;
    el.temp.max = controls.temperature.max;
    el.temp.step = controls.temperature.step;
    el.temp.value = controls.temperature.default;
    
    el.stability.min = controls.stability.min;
    el.stability.max = controls.stability.max;
    el.stability.step = controls.stability.step;
    el.stability.value = controls.stability.default;
    
    el.rad.min = controls.radiation.min;
    el.rad.max = controls.radiation.max;
    el.rad.step = controls.radiation.step;
    el.rad.value = controls.radiation.default;
    
    // Genome controls
    el.seedFert.min = controls.fertility.min;
    el.seedFert.max = controls.fertility.max;
    el.seedFert.step = controls.fertility.step;
    el.seedFert.value = controls.fertility.default;
    
    el.seedRes.min = controls.resistance.min;
    el.seedRes.max = controls.resistance.max;
    el.seedRes.step = controls.resistance.step;
    el.seedRes.value = controls.resistance.default;
    
    el.seedEff.min = controls.efficiency.min;
    el.seedEff.max = controls.efficiency.max;
    el.seedEff.step = controls.efficiency.step;
    el.seedEff.value = controls.efficiency.default;
    
    el.seedAgg.min = controls.aggressivity.min;
    el.seedAgg.max = controls.aggressivity.max;
    el.seedAgg.step = controls.aggressivity.step;
    el.seedAgg.value = controls.aggressivity.default;
    
    el.seedInf.min = controls.infectivity.min;
    el.seedInf.max = controls.infectivity.max;
    el.seedInf.step = controls.infectivity.step;
    el.seedInf.value = controls.infectivity.default;
    
    // Scatter control (select dropdown)
    el.scatter.value = controls.scatter.default;
    
    // Variance control
    el.variance.min = controls.variance.min;
    el.variance.max = controls.variance.max;
    el.variance.step = controls.variance.step;
    el.variance.value = controls.variance.default;
    
    console.log('UI initialized with config.js defaults:', {
      resources: controls.resources.default,
      temperature: controls.temperature.default,
      stability: controls.stability.default,
      radiation: controls.radiation.default
    });
  }
  
  // Initialize UI from config, then sync labels
  initializeUIFromConfig();
  syncLabels();

  // ---------- ZOOM CONTROLS ----------
  el.zoomIn.addEventListener('click', function() {
    zoomLevel = Math.min(maxZoom, zoomLevel + 0.2);
    syncLabels();
  });

  el.zoomOut.addEventListener('click', function() {
    zoomLevel = Math.max(minZoom, zoomLevel - 0.2);
    syncLabels();
  });

  el.resetZoom.addEventListener('click', function() {
    zoomLevel = minZoom; // Reset to show full world
    viewportX = 0;
    viewportY = 0;
    syncLabels();
  });

  // ---------- CANVAS INTERACTION ----------
  canvas.addEventListener('mousedown', function(e) {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });

  canvas.addEventListener('mousemove', function(e) {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      viewportX += deltaX / zoomLevel; // Natural dragging: drag left = move viewport left
      viewportY += deltaY / zoomLevel; // Natural dragging: drag up = move viewport up
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    }
  });

  canvas.addEventListener('mouseup', function() {
    isDragging = false;
    canvas.style.cursor = 'grab';
  });

  canvas.addEventListener('mouseleave', function() {
    isDragging = false;
    canvas.style.cursor = 'default';
  });

  canvas.addEventListener('wheel', function(e) {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel * zoomFactor));
    syncLabels();
  });

  // Touch event handlers for mobile support
  canvas.addEventListener('touchstart', function(e) {
    e.preventDefault();
    touches = Array.from(e.touches);
    
    if (touches.length === 1) {
      // Single touch - start panning
      isDragging = true;
      lastMouseX = touches[0].clientX;
      lastMouseY = touches[0].clientY;
    } else if (touches.length === 2) {
      // Two touches - start pinch zoom
      isPinching = true;
      isDragging = false;
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
    }
  });

  canvas.addEventListener('touchmove', function(e) {
    e.preventDefault();
    touches = Array.from(e.touches);
    
    if (touches.length === 1 && isDragging && !isPinching) {
      // Single touch panning
      const deltaX = touches[0].clientX - lastMouseX;
      const deltaY = touches[0].clientY - lastMouseY;
      
      viewportX += deltaX / zoomLevel; // Natural dragging: drag left = move viewport left
      viewportY += deltaY / zoomLevel; // Natural dragging: drag up = move viewport up
      
      lastMouseX = touches[0].clientX;
      lastMouseY = touches[0].clientY;
    } else if (touches.length === 2 && isPinching) {
      // Pinch to zoom
      const dx = touches[0].clientX - touches[1].clientX;
      const dy = touches[0].clientY - touches[1].clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (lastTouchDistance > 0) {
        const zoomFactor = distance / lastTouchDistance;
        zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel * zoomFactor));
        syncLabels();
      }
      
      lastTouchDistance = distance;
    }
  });

  canvas.addEventListener('touchend', function(e) {
    e.preventDefault();
    touches = Array.from(e.touches);
    
    if (touches.length === 0) {
      // No more touches
      isDragging = false;
      isPinching = false;
      lastTouchDistance = 0;
    } else if (touches.length === 1) {
      // Back to single touch
      isPinching = false;
      lastTouchDistance = 0;
      // Update single touch position
      lastMouseX = touches[0].clientX;
      lastMouseY = touches[0].clientY;
    }
  });

  canvas.style.cursor = 'grab';

  // ---------- PARAMETER SCATTERING SYSTEM ----------
  let parameterMap = null;
  
  function generateParameterMap() {
    const divisions = Number(el.scatter.value);
    const variance = Number(el.variance.value) / 100;
    
    if (divisions === 1) {
      parameterMap = null;
      return;
    }
    
    // Create a grid of parameter zones - divisions is already the grid size (1x1, 2x2, etc.)
    const gridSize = divisions;
    parameterMap = {
      gridSize: gridSize,
      zones: []
    };
    
    const baseParams = {
      resources: Number(el.resources.value),
      temp: Number(el.temp.value),
      stability: Number(el.stability.value),
      rad: Number(el.rad.value)
    };
    
    // Generate zones with fractal-like variation
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const zone = {};
        
        // Add variation to each parameter with enhanced temperature variance
        for (const [key, baseValue] of Object.entries(baseParams)) {
          let variation = (Math.random() - 0.5) * 2 * variance;
          
          // Increase temperature variance for more dramatic visual differences
          if (key === 'temp') {
            variation *= 1.5; // 50% more temperature variation
          }
          
          zone[key] = Math.max(0, Math.min(
            key === 'resources' ? 1000 : // Updated max for resources
            key === 'rad' ? 8 : 100, // Updated max for radiation
            baseValue * (1 + variation)
          ));
        }
        
        parameterMap.zones.push(zone);
      }
    }
    
    // Smooth neighboring zones to limit differences
    smoothParameterMap();
  }
  
  function smoothParameterMap() {
    if (!parameterMap) return;
    
    const { gridSize, zones } = parameterMap;
    const maxDifference = 0.3; // Max 30% difference between neighbors
    
    // Multiple smoothing passes
    for (let pass = 0; pass < 3; pass++) {
      for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
          const idx = y * gridSize + x;
          const zone = zones[idx];
          
          // Get neighbors
          const neighbors = [];
          for (let dy = -1; dy <= 1; dy++) {
            for (let dx = -1; dx <= 1; dx++) {
              const nx = x + dx;
              const ny = y + dy;
              if (nx >= 0 && nx < gridSize && ny >= 0 && ny < gridSize && !(dx === 0 && dy === 0)) {
                neighbors.push(zones[ny * gridSize + nx]);
              }
            }
          }
          
          // Smooth each parameter
          for (const param of ['resources', 'temp', 'stability', 'rad']) {
            if (neighbors.length > 0) {
              const avgNeighbor = neighbors.reduce((sum, n) => sum + n[param], 0) / neighbors.length;
              // Avoid division by zero when avgNeighbor is 0
              // When avgNeighbor is 0, use relative difference based on zone value to maintain scale compatibility
              const difference = avgNeighbor === 0 ? 
                (zone[param] === 0 ? 0 : 1) : // If both are 0, no difference; if zone has value but neighbors are 0, max difference
                Math.abs(zone[param] - avgNeighbor) / avgNeighbor;
              
              if (difference > maxDifference) {
                // Move towards neighbor average
                zone[param] = zone[param] * 0.7 + avgNeighbor * 0.3;
              }
            }
          }
        }
      }
    }
  }
  
  function getParametersAtPosition(x, y) {
    if (!parameterMap) {
      return {
        resources: Number(el.resources.value),
        temp: Number(el.temp.value),
        stability: Number(el.stability.value),
        rad: Number(el.rad.value)
      };
    }
    
    const { gridSize, zones } = parameterMap;
    const zoneX = Math.floor((x / WORLD_W) * gridSize);
    const zoneY = Math.floor((y / WORLD_H) * gridSize);
    const zoneIdx = Math.max(0, Math.min(zones.length - 1, zoneY * gridSize + zoneX));
    
    return zones[zoneIdx];
  }
  
  // Regenerate parameter map when scatter settings change
  el.scatter.addEventListener('change', generateParameterMap);
  el.variance.addEventListener('change', generateParameterMap);

  // ---------- SIDEBAR FUNCTIONALITY ----------
  const sidebar = document.getElementById('sidebar');
  const sidebarToggle = document.getElementById('sidebarToggle');
  
  // Sidebar toggle
  sidebarToggle.addEventListener('click', function() {
    sidebar.classList.toggle('collapsed');
    console.log('Sidebar toggled, collapsed:', sidebar.classList.contains('collapsed'));
  });
  
  // Collapsible cards
  document.querySelectorAll('.card-header').forEach(header => {
    header.addEventListener('click', function() {
      const targetId = this.getAttribute('data-target');
      const content = document.getElementById(targetId);
      const icon = this.querySelector('.collapse-icon');
      
      if (content && icon) {
        content.classList.toggle('collapsed');
        icon.classList.toggle('collapsed');
        icon.textContent = icon.classList.contains('collapsed') ? '+' : '‚àí';
      }
    });
  });

  // Panel toggles for minimap and stats
  function setupPanelToggle(toggleButton, content) {
    if (toggleButton && content) {
      toggleButton.addEventListener('click', function() {
        content.classList.toggle('collapsed');
        toggleButton.textContent = content.classList.contains('collapsed') ? '+' : '‚àí';
        
        // Save panel state to cache
        saveSettingsToCache();
      });
    }
  }

  // Panel toggles will be set up after DOM is ready


  // ---------- MINIMAP ----------
  const minimapCtx = el.minimapCanvas.getContext('2d');
  const minimapWidth = 150;
  const minimapHeight = 150;
  
  // Update ecosystem stats panel
  function updateEcosystemStats() {
    // Active cells
    el.statActiveCells.textContent = cells.length;
    
    // Available food
    el.statAvailableFood.textContent = food.length;
    
    // Infected cells
    const infectedCount = cells.filter(c => c.infected).length;
    el.statInfectedCells.textContent = infectedCount;
    
    // Total born
    el.statTotalBorn.textContent = totalBorn;
    
    // Max generation
    el.statMaxGeneration.textContent = maxGeneration;
    
    // Average lifespan
    const avgLifespan = totalDeaths > 0 ? (totalLifespan / totalDeaths) : 0;
    el.statAvgLifespan.textContent = avgLifespan.toFixed(1) + 's';
    
    // Update population graph if visible
    if (isGraphVisible && popGraphCtx) {
      updatePopulationGraph();
    }
  }
  
  function updatePopulationGraph() {
    const currentTime = (performance.now() - graphStartTime) / 1000; // Time in seconds
    
    // Add current population data point
    populationHistory.push({
      time: currentTime,
      population: cells.length
    });
    
    // Keep only last 60 seconds of data
    const maxTime = 60;
    populationHistory = populationHistory.filter(point => currentTime - point.time <= maxTime);
    
    // Draw the graph
    drawPopulationGraph();
  }
  
  function drawPopulationGraph() {
    if (!popGraphCtx || populationHistory.length < 2) return;
    
    const canvas = el.popGraphCanvas;
    const width = canvas.width;
    const height = canvas.height;
    const padding = 20;
    
    // Clear canvas
    popGraphCtx.clearRect(0, 0, width, height);
    
    // Background
    popGraphCtx.fillStyle = 'rgba(15, 22, 32, 0.9)';
    popGraphCtx.fillRect(0, 0, width, height);
    
    // Find data ranges
    const maxPop = Math.max(...populationHistory.map(p => p.population), 10);
    const minTime = Math.min(...populationHistory.map(p => p.time));
    const maxTime = Math.max(...populationHistory.map(p => p.time));
    const timeRange = Math.max(maxTime - minTime, 1);
    
    // Draw grid lines
    popGraphCtx.strokeStyle = 'rgba(148, 163, 184, 0.2)';
    popGraphCtx.lineWidth = 1;
    
    // Horizontal grid lines
    for (let i = 0; i <= 4; i++) {
      const y = padding + (i / 4) * (height - 2 * padding);
      popGraphCtx.beginPath();
      popGraphCtx.moveTo(padding, y);
      popGraphCtx.lineTo(width - padding, y);
      popGraphCtx.stroke();
    }
    
    // Vertical grid lines
    for (let i = 0; i <= 6; i++) {
      const x = padding + (i / 6) * (width - 2 * padding);
      popGraphCtx.beginPath();
      popGraphCtx.moveTo(x, padding);
      popGraphCtx.lineTo(x, height - padding);
      popGraphCtx.stroke();
    }
    
    // Draw population line
    popGraphCtx.strokeStyle = 'rgba(94, 234, 212, 0.8)';
    popGraphCtx.lineWidth = 2;
    popGraphCtx.beginPath();
    
    for (let i = 0; i < populationHistory.length; i++) {
      const point = populationHistory[i];
      const x = padding + ((point.time - minTime) / timeRange) * (width - 2 * padding);
      const y = height - padding - (point.population / maxPop) * (height - 2 * padding);
      
      if (i === 0) {
        popGraphCtx.moveTo(x, y);
      } else {
        popGraphCtx.lineTo(x, y);
      }
    }
    
    popGraphCtx.stroke();
    
    // Draw labels
    popGraphCtx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    popGraphCtx.font = '10px monospace';
    popGraphCtx.textAlign = 'left';
    
    // Y-axis labels (population)
    for (let i = 0; i <= 4; i++) {
      const pop = Math.round((maxPop * (4 - i)) / 4);
      const y = padding + (i / 4) * (height - 2 * padding) + 3;
      popGraphCtx.fillText(pop.toString(), 2, y);
    }
    
    // X-axis labels (time)
    popGraphCtx.textAlign = 'center';
    for (let i = 0; i <= 3; i++) {
      const time = Math.round(minTime + (i / 3) * timeRange);
      const x = padding + (i / 3) * (width - 2 * padding);
      popGraphCtx.fillText(time + 's', x, height - 5);
    }
    
    // Title
    popGraphCtx.textAlign = 'center';
    popGraphCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
    popGraphCtx.font = '12px monospace';
    popGraphCtx.fillText('Population vs Time', width / 2, 15);
  }

  function updateMinimap() {
    minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight);
    
    // Draw minimap background
    minimapCtx.fillStyle = '#0b0f14';
    minimapCtx.fillRect(0, 0, minimapWidth, minimapHeight);
    
    // Draw cells as dots
    minimapCtx.fillStyle = 'rgba(94, 234, 212, 0.8)';
    for (const cell of cells) {
      const x = (cell.x / WORLD_W) * minimapWidth;
      const y = (cell.y / WORLD_H) * minimapHeight;
      minimapCtx.fillRect(x - 1, y - 1, 2, 2);
    }
    
    // Draw food as smaller dots
    minimapCtx.fillStyle = 'rgba(94, 234, 212, 0.4)';
    for (const f of food) {
      const x = (f.x / WORLD_W) * minimapWidth;
      const y = (f.y / WORLD_H) * minimapHeight;
      minimapCtx.fillRect(x, y, 1, 1);
    }
    
    // Update viewport indicator
    updateViewportIndicator();
  }
  
  function updateViewportIndicator() {
    if (!el.viewportIndicator) return;
    
    // Calculate actual viewport size in world coordinates
    const viewWidthInWorld = W / zoomLevel;
    const viewHeightInWorld = H / zoomLevel;
    
    // Calculate viewport size on minimap (direct proportion)
    const viewWidth = (viewWidthInWorld / WORLD_W) * minimapWidth;
    const viewHeight = (viewHeightInWorld / WORLD_H) * minimapHeight;
    
    // Calculate viewport position on minimap
    const centerX = minimapWidth / 2;
    const centerY = minimapHeight / 2;
    const viewX = centerX - viewWidth / 2 - (viewportX / WORLD_W) * minimapWidth;
    const viewY = centerY - viewHeight / 2 - (viewportY / WORLD_H) * minimapHeight;
    
    // Clamp to minimap bounds
    const clampedX = Math.max(0, Math.min(minimapWidth - viewWidth, viewX));
    const clampedY = Math.max(0, Math.min(minimapHeight - viewHeight, viewY));
    const clampedWidth = Math.min(minimapWidth - clampedX, Math.max(1, viewWidth));
    const clampedHeight = Math.min(minimapHeight - clampedY, Math.max(1, viewHeight));
    
    el.viewportIndicator.style.left = clampedX + 'px';
    el.viewportIndicator.style.top = clampedY + 'px';
    el.viewportIndicator.style.width = clampedWidth + 'px';
    el.viewportIndicator.style.height = clampedHeight + 'px';
    el.viewportIndicator.style.display = 'block';
  }

  // ---------- World / Simulation ----------
  // Fixed world dimensions (4x bigger than viewport)
  let WORLD_W = 4000, WORLD_H = 4000;
  let W = 1, H = 1, DPR = 1; // Canvas dimensions

  function resize(){
    const rect = canvas.getBoundingClientRect();
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1)); // cap for performance
    W = Math.floor(rect.width * DPR);
    H = Math.floor(rect.height * DPR);
    canvas.width = W;
    canvas.height = H;
    ctx.setTransform(1,0,0,1,0,0);
    
    // Update minimum zoom to fit world in viewport
    const minZoomX = W / WORLD_W;
    const minZoomY = H / WORLD_H;
    minZoom = Math.max(minZoomX, minZoomY);
    
    // Ensure current zoom doesn't go below minimum
    if (zoomLevel < minZoom) {
      zoomLevel = minZoom;
      syncLabels();
    }
  }
  window.addEventListener('resize', resize);
  
  // Handle window resize for population graph positioning
  window.addEventListener('resize', function() {
    if (isGraphVisible && el.popGraphCanvas) {
      if (window.innerWidth > 768) {
        // Desktop: expanded view
        el.popGraphCanvas.width = 320;
        el.popGraphCanvas.height = 200;
      } else {
        // Mobile: compact view
        el.popGraphCanvas.width = 300;
        el.popGraphCanvas.height = 150;
      }
    }
  });

  // Ensure canvas fills remaining area
  function fitCanvasHeight(){
    // worldWrap is flex column; canvas can just fill via CSS.
    resize();
  }
  fitCanvasHeight();

  // Spatial hash grid for interactions (cells & food)
  class Grid {
    constructor(cellSize){
      this.s = cellSize;
      this.map = new Map();
    }
    key(ix, iy){ return (ix<<16) ^ (iy & 0xffff); }
    clear(){ this.map.clear(); }
    insert(x, y, item){
      const ix = (x / this.s) | 0;
      const iy = (y / this.s) | 0;
      const k = this.key(ix, iy);
      let arr = this.map.get(k);
      if(!arr){ arr = []; this.map.set(k, arr); }
      arr.push(item);
    }
    queryRadius(x, y, r){
      const s = this.s;
      const ix0 = ((x - r) / s) | 0;
      const iy0 = ((y - r) / s) | 0;
      const ix1 = ((x + r) / s) | 0;
      const iy1 = ((y + r) / s) | 0;
      const out = [];
      for(let iy=iy0; iy<=iy1; iy++){
        for(let ix=ix0; ix<=ix1; ix++){
          const k = this.key(ix, iy);
          const arr = this.map.get(k);
          if(arr) out.push(...arr);
        }
      }
      return out;
    }
    queryCellNeighborhood(x, y){
      // fixed 3x3 neighborhood
      const s = this.s;
      const ix = (x / s) | 0;
      const iy = (y / s) | 0;
      const out = [];
      for(let dy=-1; dy<=1; dy++){
        for(let dx=-1; dx<=1; dx++){
          const arr = this.map.get(this.key(ix+dx, iy+dy));
          if(arr) out.push(...arr);
        }
      }
      return out;
    }
  }

  // Entities
  let cells = [];
  let food = [];

  // World toggles / counters
  let avgMutationsPerBirth = 0;
  let births = 0;
  let generation = 0;
  let speciesCount = 0;
  
  // Ecosystem statistics tracking
  let totalBorn = 0;
  let totalDeaths = 0;
  let totalLifespan = 0;
  let maxGeneration = 0;
  
  // Population graph data
  let populationHistory = [];
  let graphStartTime = performance.now();
  let isGraphVisible = false;
  let popGraphCtx = null;
  
  // Simulation state and tracking
  let isPaused = false;
  let simulationStartTime = performance.now();
  let peakPopulation = 0;
  let extinctionEvents = 0;
  
  // Evolution Database
  let evolutionDB = null;
  let dbReady = false;
  
  // Initialize SQL.js database
  async function initEvolutionDB() {
    try {
      const SQL = await initSqlJs({
        locateFile: file => `https://sql.js.org/dist/${file}`
      });
      
      evolutionDB = new SQL.Database();
      
      // Create tables for evolution tracking
      evolutionDB.run(`
        CREATE TABLE generations (
          id INTEGER PRIMARY KEY,
          generation INTEGER,
          population INTEGER,
          avg_fitness REAL,
          avg_fertility REAL,
          avg_resistance REAL,
          avg_efficiency REAL,
          avg_aggressivity REAL,
          avg_infectivity REAL,
          species_count INTEGER,
          timestamp INTEGER
        )
      `);
      
      evolutionDB.run(`
        CREATE TABLE species (
          id INTEGER PRIMARY KEY,
          genome_signature TEXT UNIQUE,
          fertility INTEGER,
          resistance INTEGER,
          efficiency INTEGER,
          aggressivity INTEGER,
          infectivity INTEGER,
          population INTEGER,
          first_seen INTEGER,
          last_seen INTEGER,
          fitness_score REAL
        )
      `);
      
      evolutionDB.run(`
        CREATE TABLE events (
          id INTEGER PRIMARY KEY,
          generation INTEGER,
          event_type TEXT,
          description TEXT,
          impact_level INTEGER,
          timestamp INTEGER
        )
      `);
      
      dbReady = true;
      console.log('Evolution database initialized successfully!');
      
    } catch (error) {
      console.error('Failed to initialize evolution database:', error);
    }
  }

  // Load configuration values (now using config.js)
  const FOOD_ENERGY = EvoSimConfig.simulation.foodEnergy;
  const BASE_DRAIN = EvoSimConfig.simulation.baseDrain;
  const HEALTH_DRAIN_TEMP = EvoSimConfig.simulation.healthDrainTemp;
  const REPRO_THRESHOLD = EvoSimConfig.simulation.reproductionThreshold;
  const REPRO_COST = EvoSimConfig.simulation.reproductionCost;
  const MAX_CELLS_SOFT = EvoSimConfig.simulation.maxCellsSoft;
  const FOOD_CAP = EvoSimConfig.simulation.maxFood;

  // Plague configuration (now using config.js)
  const PLAGUE_DENSITY_TRIGGER = EvoSimConfig.plague.densityTrigger;
  const PLAGUE_TIMER_BASE = EvoSimConfig.plague.timerBase;
  const PLAGUE_TIMER_MIN = EvoSimConfig.plague.timerMin;
  const PLAGUE_SPREAD_BASE = EvoSimConfig.plague.spreadBase;
  const PLAGUE_SPREAD_PER = EvoSimConfig.plague.spreadPerLevel;

  // Radiation -> mutation strength
  function mutationDelta(radiation){
    // radiation 0 => mostly 0; radiation 8 => -3..+3 often (PRD spec)
    if(radiation <= 0) return 0;
    const p = clamp(radiation / 8, 0, 1);
    // biased toward small deltas
    const roll = Math.random();
    if(roll < (0.45 - 0.25*p)) return 0;
    if(roll < (0.70 - 0.15*p)) return (Math.random()<0.5 ? -1 : 1);
    if(roll < (0.90 - 0.10*p)) return (Math.random()<0.5 ? -2 : 2);
    return (Math.random()<0.5 ? -3 : 3); // Stronger mutations possible
  }

  function maybeMutateGenome(gen, rad){
    // mutate 0..3 traits depending on rad (expanded range)
    if(rad <= 0) return gen;
    const out = gen.slice();
    const changes = (Math.random() < rad/12) ? (Math.random() < 0.3 ? 3 : 2) : 1; // More changes possible
    for(let i=0;i<changes;i++){
      const idx = irand(0,4);
      out[idx] = clamp(out[idx] + mutationDelta(rad), 0, 7); // 3-bit genome range
    }
    return out;
  }

  function tempToIdealLevel(temp0_100){
    // map world temp to 0..7 (3-bit genome range)
    return clamp(Math.round((temp0_100/100)*7), 0, 7);
  }

  function efficiencyToRadius(eff){
    // 3-bit genome (0-7) with config scaling
    const { efficiencyRadiusRange } = EvoSimConfig.genetics;
    return lerp(efficiencyRadiusRange.min, efficiencyRadiusRange.max, eff/7);
  }

  function fertilityToSides(f){
    // 3-bit genome (0-7) with config scaling
    if(f <= 0) return 0; // circle
    const { fertilityShapeRange } = EvoSimConfig.genetics;
    const sides = Math.round(lerp(fertilityShapeRange.min, fertilityShapeRange.max, f/7));
    return clamp(sides, 3, 20);
  }

  class Cell {
    constructor(x, y, genome, generation = 0){
      this.x = x; this.y = y;
      this.vx = rand(-18, 18);
      this.vy = rand(-18, 18);
      this.genome = genome.slice(); // [fert,res,eff,agg,inf]
      this.energy = rand(35, 55);
      this.health = 100;
      this.age = 0;
      this.generation = generation; // Track how many times this lineage has divided
      this.naturalRadiationResistance = 0.5; // 50% natural immunity to radiation damage

      this.infected = false;
      this.plagueT = 0;
      this.currentInfectivity = this.genome[4]; // Track current infection level separately

      this._r = efficiencyToRadius(this.genome[2]);
      this._glow = this.genome[3]/7;
    }

    get r(){ return this._r; }
    updateDerived(){
      this._r = efficiencyToRadius(this.genome[2]);
      this._glow = (this.genome[3] * EvoSimConfig.genetics.aggressivityGlowScale) / 17.5;
    }

    infect(level){
      // Set current infection level without modifying genome (genome is immutable)
      this.currentInfectivity = clamp(level, 0, 7);
      if(this.currentInfectivity > 3){ // PRD spec threshold
        this.infected = true;
        // timer shorter with higher infectivity
        const t = lerp(PLAGUE_TIMER_BASE, PLAGUE_TIMER_MIN, (this.currentInfectivity-3)/4);
        this.plagueT = t;
      } else {
        this.infected = false;
        this.plagueT = 0;
      }
    }
  }

  function resetWorld(seedGenome){
    cells.length = 0;
    food.length = 0;
    births = 0;
    avgMutationsPerBirth = 0;
    generation = 0;
    speciesCount = 0;

    // Clear any existing spawn timeout
    if (window.spawnTimeout) {
      clearTimeout(window.spawnTimeout);
    }

    console.log('World reset. Cell will spawn in 3 seconds near resources...');
    
    // Show countdown notification
    showEventNotification('World Reset', 'New cell will spawn in 3 seconds near closest resources...');
    
    // Delayed spawn after 3 seconds
    window.spawnTimeout = setTimeout(() => {
      spawnInitialCellNearResources(seedGenome);
    }, 3000);
  }
  
  // Natural resource recycling - resources appear where the organism died
  function recycleDeadCell(cell) {
    console.log(`üíÄ Cell died at (${cell.x.toFixed(0)}, ${cell.y.toFixed(0)}) - Age: ${cell.age.toFixed(1)}s, Energy: ${cell.energy.toFixed(1)}, Health: ${cell.health.toFixed(1)}`);
    
    // Track ecosystem statistics
    totalDeaths++;
    totalLifespan += cell.age;
    maxGeneration = Math.max(maxGeneration, cell.generation);
    
    // Ensure we don't exceed food cap before recycling
    const foodSpaceBefore = FOOD_CAP - food.length;
    console.log(`üçñ Food space available: ${foodSpaceBefore}/${FOOD_CAP}`);
    // Calculate total resources to recycle based on cell's accumulated energy and biomass
    const baseRecycling = FOOD_ENERGY * 0.8; // Base biomass return
    const energyRecycling = Math.max(0, cell.energy * 0.7); // 70% of remaining energy
    const ageBonus = Math.min(cell.age * 2, FOOD_ENERGY * 0.5); // Age adds biomass
    
    const totalEnergy = baseRecycling + energyRecycling + ageBonus;
    
    // Determine number of food particles based on cell size and energy
    const cellSize = cell.r;
    const sizeMultiplier = cellSize / 6; // Larger cells = more particles
    const energyMultiplier = Math.max(1, cell.energy / 40); // High energy cells = more particles
    const foodCount = Math.ceil(sizeMultiplier * energyMultiplier * (0.8 + Math.random() * 0.4)); // 1-4 particles typically
    
    // Distribute energy across multiple food particles
    const energyPerFood = totalEnergy / Math.max(1, foodCount);
    
    // Guarantee resource recycling - always create at least one food particle
    let particlesCreated = 0;
    
    // Spawn food particles in immediate proximity - very close to death site
    for (let i = 0; i < foodCount; i++) {
      // Create a tight cluster around the death site
      const angle = (Math.PI * 2 * i) / foodCount + Math.random() * 0.3; // Less randomness for tighter clustering
      const distance = Math.random() * cell.r * 0.8 + cell.r * 0.2; // Very close: 0.2x to 1x cell radius
      
      // Position food particles right at the death site
      const foodX = clamp(cell.x + Math.cos(angle) * distance, cell.r, WORLD_W - cell.r);
      const foodY = clamp(cell.y + Math.sin(angle) * distance, cell.r, WORLD_H - cell.r);
      
      // Force creation of recycled food even if near cap (remove oldest food if needed)
      if (food.length >= FOOD_CAP && particlesCreated === 0) {
        // Remove oldest environmental food to make room for recycled resources
        for (let j = 0; j < food.length; j++) {
          if (!food[j].recycled) {
            food.splice(j, 1);
            break;
          }
        }
      }
      
      if (food.length < FOOD_CAP) {
        food.push({
          x: foodX,
          y: foodY,
          e: energyPerFood,
          a: 1.0, // Maximum visibility for recycled resources
          recycled: true,
          deathTime: performance.now() // Track when this resource was created
        });
        particlesCreated++;
      }
    }
    
    // Immediate feeding opportunity - create a "feeding frenzy" zone
    // Always spawn fresh carrion regardless of energy level (guaranteed resource recycling)
    if (food.length >= FOOD_CAP) {
      // Remove oldest environmental food to make room for fresh carrion
      for (let j = 0; j < food.length; j++) {
        if (!food[j].recycled && !food[j].fresh) {
          food.splice(j, 1);
          break;
        }
      }
    }
    
    if (food.length < FOOD_CAP) {
      food.push({
        x: clamp(cell.x + rand(-cell.r * 0.2, cell.r * 0.2), cell.r, WORLD_W - cell.r), // Very close to death site, clamped to world bounds
        y: clamp(cell.y + rand(-cell.r * 0.2, cell.r * 0.2), cell.r, WORLD_H - cell.r),
        e: Math.max(energyPerFood * 1.5, FOOD_ENERGY), // Guaranteed substantial energy
        a: 1.0, // Fully visible
        recycled: true,
        fresh: true, // Mark as fresh carrion for immediate consumption
        deathTime: performance.now(),
        persistent: true // Mark as high-priority resource
      });
      particlesCreated++;
    }
    
    // Environmental feedback and recycling confirmation
    const totalParticles = particlesCreated;
    console.log(`üçñ Recycling complete: ${cell.age.toFixed(1)}s old cell ‚Üí ${totalParticles} food particles at (${cell.x.toFixed(0)}, ${cell.y.toFixed(0)}) | Total energy recycled: ${(totalParticles * energyPerFood).toFixed(1)}`);
    
    // Ensure at least one particle was created
    if (totalParticles === 0) {
      console.error('‚ö†Ô∏è RECYCLING FAILED: No food particles created!');
      // Emergency fallback - force create one particle
      if (food.length > 0) {
        food.pop(); // Remove one existing food
      }
      food.push({
        x: cell.x,
        y: cell.y,
        e: FOOD_ENERGY,
        a: 1.0,
        recycled: true,
        fresh: true,
        emergency: true
      });
      console.log('üö® Emergency food particle created');
    }
  }

  function spawnInitialCellNearResources(seedGenome) {
    // Define center and spawn radius (1/6th of map size)
    const centerX = WORLD_W * 0.5;
    const centerY = WORLD_H * 0.5;
    const spawnRadius = Math.min(WORLD_W, WORLD_H) / 6; // 1/6th of smaller dimension
    
    // First, spawn some initial food to find resources
    const initialFoodCount = Math.floor(FOOD_CAP * 0.1); // 10% of food cap
    spawnFood(initialFoodCount);
    
    // Filter food to only those within spawn radius from center
    const centralFood = food.filter(f => {
      const dx = f.x - centerX;
      const dy = f.y - centerY;
      const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
      return distanceFromCenter <= spawnRadius;
    });
    
    if (centralFood.length < 2) {
      // Fallback: spawn randomly within the central radius
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * spawnRadius * 0.5; // Within inner half of radius
      const spawnX = centerX + Math.cos(angle) * distance;
      const spawnY = centerY + Math.sin(angle) * distance;
      
      cells.push(new Cell(spawnX, spawnY, seedGenome));
      console.log(`Cell spawned at (${spawnX.toFixed(0)}, ${spawnY.toFixed(0)}) in central area (limited resources)`);
      showEventNotification('Cell Spawned', `New cell born in central area!`);
      return;
    }
    
    // Find the two closest food items to each other within central area
    let minDistance = Infinity;
    let closestPair = [centralFood[0], centralFood[1]];
    
    for (let i = 0; i < centralFood.length - 1; i++) {
      for (let j = i + 1; j < centralFood.length; j++) {
        const dx = centralFood[i].x - centralFood[j].x;
        const dy = centralFood[i].y - centralFood[j].y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestPair = [centralFood[i], centralFood[j]];
        }
      }
    }
    
    // Calculate spawn position between closest resources
    let spawnX = (closestPair[0].x + closestPair[1].x) / 2;
    let spawnY = (closestPair[0].y + closestPair[1].y) / 2;
    
    // Ensure spawn position is within the central radius (safety check)
    const spawnDistanceFromCenter = Math.sqrt((spawnX - centerX) ** 2 + (spawnY - centerY) ** 2);
    if (spawnDistanceFromCenter > spawnRadius) {
      // Pull spawn position back to edge of allowed radius
      const ratio = spawnRadius / spawnDistanceFromCenter;
      spawnX = centerX + (spawnX - centerX) * ratio;
      spawnY = centerY + (spawnY - centerY) * ratio;
    }
    
    cells.push(new Cell(spawnX, spawnY, seedGenome, 0)); // Start with generation 0
    
    console.log(`Cell spawned at (${spawnX.toFixed(0)}, ${spawnY.toFixed(0)}) within central radius (${spawnRadius.toFixed(0)}px)`);
    showEventNotification('Cell Spawned', `New cell born in central area between resources!`);
  }

  function seedGenomeFromUI(){
    return [
      Number(el.seedFert.value),
      Number(el.seedRes.value),
      Number(el.seedEff.value),
      Number(el.seedAgg.value),
      Number(el.seedInf.value),
    ];
  }
  
  // Species classification system
  function getGenomeSignature(genome) {
    // Create a signature for species identification
    return genome.map(g => Math.floor(g / 2) * 2).join('-');
  }
  
  function calculateFitness(cell) {
    // Fitness based on survival time, reproduction success, and adaptability
    const survivalScore = Math.min(cell.age / 10, 10); // Max 10 points for survival
    const energyScore = Math.min(cell.energy / 20, 5); // Max 5 points for energy
    const healthScore = Math.min(cell.health / 20, 5); // Max 5 points for health
    return survivalScore + energyScore + healthScore;
  }
  
  function updateSpeciesDatabase() {
    if (!dbReady) return;
    
    try {
      const speciesMap = new Map();
      const currentTime = Date.now();
      
      // Analyze current population
      for (const cell of cells) {
        const signature = getGenomeSignature(cell.genome);
        const fitness = calculateFitness(cell);
        
        if (!speciesMap.has(signature)) {
          speciesMap.set(signature, {
            genome: cell.genome.slice(),
            population: 0,
            totalFitness: 0
          });
        }
        
        const species = speciesMap.get(signature);
        species.population++;
        species.totalFitness += fitness;
      }
      
      // Update database
      speciesMap.forEach((data, signature) => {
        const avgFitness = data.totalFitness / data.population;
        const [fert, res, eff, agg, inf] = data.genome;
        
        evolutionDB.run(`
          INSERT OR REPLACE INTO species (
            genome_signature, fertility, resistance, efficiency, 
            aggressivity, infectivity, population, last_seen, fitness_score
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [signature, fert, res, eff, agg, inf, data.population, currentTime, avgFitness]);
      });
      
      speciesCount = speciesMap.size;
      
    } catch (error) {
      console.error('Species database update failed:', error);
    }
  }
  
  function updateGenerationData() {
    if (!dbReady || cells.length === 0) return;
    
    try {
      // Calculate population statistics
      const totalCells = cells.length;
      let totalFitness = 0;
      let avgGenome = [0, 0, 0, 0, 0];
      
      for (const cell of cells) {
        totalFitness += calculateFitness(cell);
        for (let i = 0; i < 5; i++) {
          avgGenome[i] += cell.genome[i];
        }
      }
      
      const avgFitness = totalFitness / totalCells;
      avgGenome = avgGenome.map(sum => sum / totalCells);
      
      // Store generation data
      evolutionDB.run(`
        INSERT INTO generations (
          generation, population, avg_fitness, avg_fertility, avg_resistance,
          avg_efficiency, avg_aggressivity, avg_infectivity, species_count, timestamp
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `, [
        generation, totalCells, avgFitness, avgGenome[0], avgGenome[1],
        avgGenome[2], avgGenome[3], avgGenome[4], speciesCount, Date.now()
      ]);
      
      console.log(`Generation ${generation}: ${totalCells} cells, ${speciesCount} species, fitness: ${avgFitness.toFixed(2)}`);
      
    } catch (error) {
      console.error('Generation data update failed:', error);
    }
  }
  
  // Ecosystem Events System
  function triggerEcosystemEvent() {
    const events = [
      {
        name: "Meteor Impact",
        description: "A meteor strikes! High radiation and cell death.",
        effect: () => {
          // Kill most cells, leaving 0.1% to 50% survivors (extremely dramatic range)
          const survivalRate = 0.001 + Math.random() * 0.499; // 0.1% to 50%
          const survivorCount = Math.max(1, Math.floor(cells.length * survivalRate));
          const killCount = cells.length - survivorCount;
          
          // Kill random cells
          for (let i = 0; i < killCount; i++) {
            if (cells.length > survivorCount) {
              const idx = Math.floor(Math.random() * cells.length);
              cells.splice(idx, 1);
            }
          }
          // Temporarily increase radiation
          el.rad.value = Math.min(15, Number(el.rad.value) + 5);
          syncLabels();
          setTimeout(() => {
            el.rad.value = Math.max(0, Number(el.rad.value) - 5);
            syncLabels();
          }, 10000);
        }
      },
      {
        name: "Food Abundance",
        description: "Rich nutrients discovered! Food spawning increased.",
        effect: () => {
          // Spawn extra food
          spawnFood(Math.floor(FOOD_CAP * 0.5));
          // Temporarily increase resource density
          el.resources.value = Math.min(200, Number(el.resources.value) + 30);
          syncLabels();
          setTimeout(() => {
            el.resources.value = Math.max(0, Number(el.resources.value) - 30);
            syncLabels();
          }, 15000);
        }
      },
      {
        name: "Climate Shift",
        description: "Temperature fluctuation challenges adaptation.",
        effect: () => {
          // Random temperature change
          const tempChange = (Math.random() - 0.5) * 40;
          el.temp.value = Math.max(0, Math.min(100, Number(el.temp.value) + tempChange));
          syncLabels();
        }
      },
      {
        name: "Solar Flare",
        description: "Intense radiation damages cellular health.",
        effect: () => {
          // Damage living cells instead of mutating them (genomes are immutable)
          for (const cell of cells) {
            if (Math.random() < 0.4) {
              cell.health -= Math.random() * 30 + 10; // 10-40 damage
            }
          }
        }
      }
    ];
    
    const event = events[Math.floor(Math.random() * events.length)];
    event.effect();
    
    // Log to database
    if (dbReady) {
      evolutionDB.run(`
        INSERT INTO events (generation, event_type, description, impact_level, timestamp)
        VALUES (?, ?, ?, ?, ?)
      `, [generation, event.name, event.description, 3, Date.now()]);
    }
    
    // Show event notification
    showEventNotification(event.name, event.description);
    
    console.log(`üåü Ecosystem Event: ${event.name} - ${event.description}`);
  }
  
  function showEventNotification(title, description) {
    const notification = document.createElement('div');
    notification.className = 'event-notification';
    notification.innerHTML = `
      <div class="event-title">${title}</div>
      <div class="event-description">${description}</div>
    `;
    
    el.evolutionEvents.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 5000);
  }

  el.inject.addEventListener('click', () => {
    console.log('Injecting new cell and restarting world...');
    
    // Disable button temporarily to prevent multiple clicks
    el.inject.disabled = true;
    el.inject.textContent = 'Preparing world...';
    
    resetWorld(seedGenomeFromUI());
    generateParameterMap();
    
    // Re-enable button after spawn delay
    setTimeout(() => {
      el.inject.disabled = false;
      el.inject.textContent = 'Inject Cell / Restart World';
    }, 3500);
  });

  // Initialize evolution database
  initEvolutionDB();
  
  // Initialize canvas size
  resize();
  
  // Load cached settings first, then initialize with defaults if no cache
  const settingsLoaded = loadSettingsFromCache();
  if (!settingsLoaded) {
    initializeUIFromConfig();
  }
  
  // Add event listeners to save settings when they change
  const settingsInputs = [
    el.resources, el.temp, el.stability, el.rad,
    el.seedFert, el.seedRes, el.seedEff, el.seedAgg, el.seedInf,
    el.scatter, el.variance
  ];
  
  settingsInputs.forEach(input => {
    input.addEventListener('change', saveSettingsToCache);
    input.addEventListener('input', saveSettingsToCache);
  });
  
  // Save settings when sidebar or cards are toggled
  sidebarToggle.addEventListener('click', () => {
    setTimeout(saveSettingsToCache, 100); // Delay to ensure class is applied
  });
  
  document.querySelectorAll('.card-header').forEach(header => {
    header.addEventListener('click', () => {
      setTimeout(saveSettingsToCache, 100); // Delay to ensure class is applied
    });
  });
  
  // Initialize with UI seed
  resetWorld(seedGenomeFromUI());
  
  // Initialize parameter map
  generateParameterMap();
  
  // Initialize minimap
  if (el.minimapCanvas && minimapCtx) {
    console.log('Minimap initialized successfully');
    updateMinimap();
    
    // Add click navigation to minimap
    el.minimapCanvas.addEventListener('click', function(e) {
      const rect = el.minimapCanvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Convert minimap coordinates to world coordinates
      const worldX = (clickX / minimapWidth) * WORLD_W;
      const worldY = (clickY / minimapHeight) * WORLD_H;
      
      // Center viewport on clicked location
      viewportX = (WORLD_W / 2) - worldX;
      viewportY = (WORLD_H / 2) - worldY;
      
      updateMinimap();
    });
    
    el.minimapCanvas.style.cursor = 'pointer';
  } else {
    console.error('Minimap initialization failed');
  }
  
  // Setup panel toggles independently of minimap initialization
  console.log('Setting up panel toggles...');
  setupPanelToggle(el.minimapToggle, el.minimapContent);
  setupPanelToggle(el.statsToggle, el.statsContent);
  console.log('Panel toggles initialized');
  
  // Initialize population graph
  if (el.popGraphCanvas) {
    popGraphCtx = el.popGraphCanvas.getContext('2d');
  }
  
  // Population graph toggle
  if (el.togglePopGraph) {
    el.togglePopGraph.addEventListener('click', function() {
      isGraphVisible = !isGraphVisible;
      
      if (isGraphVisible) {
        el.populationGraph.style.display = 'block';
        el.populationGraph.classList.add('expanded');
        el.togglePopGraph.textContent = 'üìä Hide Population Graph';
        
        // Reset graph data when showing
        populationHistory = [];
        graphStartTime = performance.now();
        
        // Resize canvas for desktop expanded view
        if (window.innerWidth > 768) {
          el.popGraphCanvas.width = 320;
          el.popGraphCanvas.height = 200;
        }
      } else {
        el.populationGraph.style.display = 'none';
        el.populationGraph.classList.remove('expanded');
        el.togglePopGraph.textContent = 'üìä Show Population Graph';
        
        // Reset canvas size
        el.popGraphCanvas.width = 300;
        el.popGraphCanvas.height = 150;
      }
    });
  }
  
  // Pause button functionality
  if (el.pauseBtn) {
    el.pauseBtn.addEventListener('click', function() {
      isPaused = !isPaused;
      el.pauseBtn.textContent = isPaused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
      el.pauseBtn.title = isPaused ? 'Resume Simulation' : 'Pause Simulation';
      
      if (isPaused) {
        showStatsSummary();
      } else {
        hideStatsSummary();
      }
    });
  }
  
  // Stats summary modal controls
  if (el.closeStatsModal) {
    el.closeStatsModal.addEventListener('click', hideStatsSummary);
  }
  
  if (el.resumeBtn) {
    el.resumeBtn.addEventListener('click', function() {
      isPaused = false;
      el.pauseBtn.textContent = '‚è∏Ô∏è';
      el.pauseBtn.title = 'Pause Simulation';
      hideStatsSummary();
    });
  }
  
  if (el.restartBtn) {
    el.restartBtn.addEventListener('click', function() {
      // Reset simulation
      resetWorld([3,3,4,2,0]);
      isPaused = false;
      el.pauseBtn.textContent = '‚è∏Ô∏è';
      el.pauseBtn.title = 'Pause Simulation';
      simulationStartTime = performance.now();
      peakPopulation = 0;
      extinctionEvents = 0;
      totalBorn = 0;
      totalDeaths = 0;
      totalLifespan = 0;
      maxGeneration = 0;
      hideStatsSummary();
    });
  }
  
  function showStatsSummary() {
    updateStatsSummary();
    el.statsSummaryModal.style.display = 'flex';
  }
  
  function hideStatsSummary() {
    el.statsSummaryModal.style.display = 'none';
  }
  
  function updateStatsSummary() {
    const runtime = (performance.now() - simulationStartTime) / 1000;
    const avgLifespan = totalDeaths > 0 ? (totalLifespan / totalDeaths) : 0;
    
    el.summaryRuntime.textContent = runtime.toFixed(1) + 's';
    el.summaryPeakPop.textContent = peakPopulation;
    el.summaryTotalBirths.textContent = totalBorn;
    el.summaryTotalDeaths.textContent = totalDeaths;
    el.summaryMaxGen.textContent = maxGeneration;
    el.summaryAvgLifespan.textContent = avgLifespan.toFixed(1) + 's';
    el.summaryExtinctions.textContent = extinctionEvents;
    el.summaryFinalPop.textContent = cells.length;
  }
  
  // Start the simulation
  console.log('Starting EvoSimGame simulation...');

  // Food spawning with parameter zones
  function spawnFood(n){
    if(n <= 0) return;
    const max = Math.max(0, FOOD_CAP - food.length);
    n = Math.min(n, max);
    
    for(let i=0;i<n;i++){
      const x = rand(10, WORLD_W-10);
      const y = rand(10, WORLD_H-10);
      
      // Get local parameters for this position
      const localParams = getParametersAtPosition(x, y);
      const localDensity = localParams.resources / 1000; // Updated for new max range
      
      // Only spawn food if local density allows it
      if(Math.random() < localDensity) {
        food.push({
          x: x,
          y: y,
          e: FOOD_ENERGY * (0.8 + 0.4 * localDensity), // Vary energy based on local density
          // slight variation for visuals
          a: rand(0.65, 1.0),
          // Mark as environmental food (no deathTime = environmental)
          type: 'environmental'
        });
      }
    }
  }

  // ---------- Main Loop ----------
  const gridCellSize = EvoSimConfig.simulation.gridCellSize;
  const cellGrid = new Grid(gridCellSize);
  const foodGrid = new Grid(gridCellSize);

  let last = performance.now();
  let renderFrameCount = 0;
  let lastFPSCheck = 0;
  let currentFPS = 60;

  function step(now){
    try {
      // Always render even when paused, but don't update simulation
      if (isPaused) {
        draw(Number(el.temp.value), Number(el.stability.value), Number(el.rad.value), 0);
        requestAnimationFrame(step);
        return;
      }
      
      const dt = Math.min(0.033, (now - last)/1000); // cap for stability
      last = now;
      
      // Performance monitoring and adaptive rendering
      renderFrameCount++;
      if (now - lastFPSCheck > 1000) { // Check FPS every second
        currentFPS = renderFrameCount;
        renderFrameCount = 0;
        lastFPSCheck = now;
      }
      
      // Performance monitoring
      if (cells.length > MAX_CELLS_SOFT * 1.5) {
        console.warn('Cell population exceeding safe limits:', cells.length);
      }

    const resources = Number(el.resources.value);
    const temp = Number(el.temp.value);
    const stability = Number(el.stability.value);
    const rad = Number(el.rad.value);

    // Radiation level 8: immediate death (PRD spec)
    if(rad >= 8){
      // draw quick flash and kill all cells
      cells.length = 0;
      // food still spawns but irrelevant
      spawnFood(Math.floor((resources/100) * 6));
      draw(temp, stability, rad, dt);
      requestAnimationFrame(step);
      return;
    }

    // Spawn food: density-based system with area scaling
    const worldArea = WORLD_W * WORLD_H;
    const baseArea = 800 * 600; // Reference area
    const areaScale = Math.min(worldArea / baseArea, 4); // Cap scaling at 4x
    
    // Food spawning (now using config.js)
    const resourceDensity = resources / 1000; // Updated for new max range
    const spawnBase = resourceDensity * EvoSimConfig.simulation.foodSpawnBase * areaScale;
    const instability = 1 - (stability/100);
    const { stabilityFoodFactor, foodSpawnVariability } = EvoSimConfig.simulation;
    const spawnFactor = lerp(stabilityFoodFactor.min, stabilityFoodFactor.max, instability) * 
                       (1 - foodSpawnVariability + foodSpawnVariability * 2 * Math.random());
    const spawnN = Math.floor(spawnBase * spawnFactor * dt * 60);
    spawnFood(spawnN);

    // Build grids
    cellGrid.clear();
    foodGrid.clear();
    for(const f of food) foodGrid.insert(f.x, f.y, f);
    for(const c of cells) cellGrid.insert(c.x, c.y, c);

    // Density-based plague signal (used to auto-trigger in dense populations)
    const plagueArea = WORLD_W * WORLD_H;
    const density = cells.length / Math.max(1, plagueArea);
    const plaguePressure = clamp((density - PLAGUE_DENSITY_TRIGGER) / (PLAGUE_DENSITY_TRIGGER*1.8), 0, 1);

    // Update cells
    const idealRes = tempToIdealLevel(temp);

    // Avoid runaway by scaling reproduction when crowded
    const crowd = clamp(cells.length / MAX_CELLS_SOFT, 0, 2);
    const reproThrottle = 1 / (1 + crowd*1.2);

    // Movement physics (now using config.js)
    const { baseJitter, baseWander, baseFriction } = EvoSimConfig.simulation;
    const jitter = lerp(baseJitter.max, baseJitter.min, stability/100); // px/s^2
    const wander = lerp(baseWander.max, baseWander.min, stability/100); // px/s
    const friction = lerp(baseFriction.min, baseFriction.max, stability/100); // per tick

    // Process in reverse so splices are safe
    const newborns = [];

    for(let i=cells.length-1; i>=0; i--){
      const c = cells[i];
      c.age += dt;

      // Radiation: only affects health/death, not genome (genome is immutable after birth)
      if(rad > 0){
        // Apply natural radiation resistance (50% immunity by default)
        const effectiveRadiation = Math.max(0, rad - (8 * c.naturalRadiationResistance));
        if(effectiveRadiation > 0) {
          const radiationDamage = (effectiveRadiation / 8) * EvoSimConfig.genetics.radiationHealthDamage * dt;
          c.health -= radiationDamage;
        }
      }

      // Brownian wandering
      c.vx += rand(-jitter, jitter) * dt;
      c.vy += rand(-jitter, jitter) * dt;

      // Bias wandering a bit so they don't freeze
      const sp = Math.hypot(c.vx, c.vy) + 1e-6;
      if(sp < wander){
        c.vx += (rand(-1,1) * wander) * dt;
        c.vy += (rand(-1,1) * wander) * dt;
      }

      c.vx *= friction;
      c.vy *= friction;

      c.x += c.vx * dt * 30; // scale up to feel alive
      c.y += c.vy * dt * 30;

      // Bounce bounds (use world coordinates, not screen coordinates)
      if(c.x < c.r){ c.x = c.r; c.vx *= -0.8; }
      if(c.y < c.r){ c.y = c.r; c.vy *= -0.8; }
      if(c.x > WORLD_W-c.r){ c.x = WORLD_W-c.r; c.vx *= -0.8; }
      if(c.y > WORLD_H-c.r){ c.y = WORLD_H-c.r; c.vy *= -0.8; }

      // Energy drain: higher efficiency => lower drain (using 3-bit genome)
      const eff = c.genome[2];
      const drain = BASE_DRAIN * lerp(1.35, 0.35, eff/7); // 3-bit genome scaling
      c.energy -= drain * dt * 10;

      // Temperature mismatch health drain (quadratic scaling for stronger delta effect)
      const res = c.genome[1];
      const mismatch = Math.abs(res - idealRes) / 7; // 3-bit genome range
      const tempDamage = HEALTH_DRAIN_TEMP * (mismatch * mismatch) * dt * 10; // Quadratic for stronger delta punishment
      c.health -= tempDamage;

      // Low energy also hurts
      if(c.energy < 0){
        c.health += c.energy * 0.6; // energy negative reduces health
        c.energy = 0;
      }

      // Eat nearby food
      const eatR = c.r + 6;
      const candidates = foodGrid.queryRadius(c.x, c.y, eatR);
      for(let k=candidates.length-1; k>=0; k--){
        const f = candidates[k];
        if(!f) continue;
        const dx = f.x - c.x, dy = f.y - c.y;
        if(dx*dx + dy*dy <= eatR*eatR){
          c.energy += f.e;
          // remove food (swap-pop)
          const idx = food.indexOf(f);
          if(idx !== -1){
            food[idx] = food[food.length-1];
            food.pop();
          }
        }
      }

      // Plague mechanics
      const inf = c.currentInfectivity;

      // Overpopulation + Infectivity > 3 triggers plague more readily (PRD spec)
      if(inf > 3){
        // If not already infected, density can "ignite" the timer
        if(!c.infected){
          const igniteChance = (0.02 + 0.18*plaguePressure) * dt * 10;
          if(Math.random() < igniteChance){
            c.infect(inf);
          }
        }
      } else {
        // if infectivity dropped, clear infection
        if(c.infected) c.infect(inf);
      }

      // Spread infection by proximity (touching OR in radius)
      if(inf > 0){
        const spreadR = PLAGUE_SPREAD_BASE + inf*PLAGUE_SPREAD_PER;
        const neigh = cellGrid.queryRadius(c.x, c.y, spreadR);
        for(const other of neigh){
          if(other === c) continue;
          const dx = other.x - c.x, dy = other.y - c.y;
          if(dx*dx + dy*dy <= spreadR*spreadR){
            // Infectivity transmission: touching or entering radius infects target with same level
            if(other.currentInfectivity !== inf){
              // Make it harder for low infectivity to overwrite higher
              if(inf >= other.currentInfectivity || Math.random() < 0.2 + 0.1*inf){
                other.infect(inf);
              }
            }
          }
        }
      }

      // If infected (infectivity > 3), countdown to death
      if(c.infected){
        // more pressure in dense pops -> faster death spiral
        c.plagueT -= dt * (1 + 1.2*plaguePressure);
        c.health -= dt * (6 + 10*plaguePressure);
        if(c.plagueT <= 0){
          // Enhanced resource recycling for plague deaths
          recycleDeadCell(c);
          cells[i] = cells[cells.length-1];
          cells.pop();
          continue;
        }
      }

      // Predation (Aggressivity): attack smaller on contact; gain energy
      const agg = c.genome[3];
      if(agg >= 3 && cells.length > 1){ // PRD threshold for hunting
        const { aggressivityHuntRange } = EvoSimConfig.genetics;
        const huntR = c.r + lerp(aggressivityHuntRange.min, aggressivityHuntRange.max, agg/7);
        const neigh = cellGrid.queryCellNeighborhood(c.x, c.y);
        for(const other of neigh){
          if(other === c) continue;
          // Attack smaller cells (predator-prey mechanics)
          if(other.r >= c.r) continue; // Only attack smaller cells

          const dx = other.x - c.x, dy = other.y - c.y;
          const rr = huntR + other.r;
          if(dx*dx + dy*dy <= rr*rr){
            // kill target and gain energy (using config values)
            const gain = EvoSimConfig.predation.baseEnergyGain + 
                        other.energy * EvoSimConfig.predation.energyGainFactor;
            c.energy += gain;
            other.health = -999; // mark for removal
          }
        }
      }

      // Cull any marked prey
      if(cells[i] && cells[i].health <= 0){
        // Enhanced resource recycling - return cell's energy to ecosystem
        recycleDeadCell(c);
        cells[i] = cells[cells.length-1];
        cells.pop();
        continue;
      }

      // Reproduction: based on fertility & energy, modulated by throttle and stability
      const fert = c.genome[0];
      if(cells.length < EvoSimConfig.simulation.maxCellsHard){
        const baseReproRate = lerp(EvoSimConfig.reproduction.baseRate.min, 
                                  EvoSimConfig.reproduction.baseRate.max, fert/7); // 3-bit genome
        const stabilityPenalty = lerp(1.0, 1.0 - EvoSimConfig.reproduction.stabilityPenalty, instability);
        const reproRate = baseReproRate * reproThrottle * stabilityPenalty;
        if(c.energy > REPRO_THRESHOLD && Math.random() < reproRate * dt){
          // split
          c.energy -= REPRO_COST;
          const childGenome = c.genome.slice();

          // mutate during reproduction based on radiation
          const before = childGenome.slice();
          const mutated = maybeMutateGenome(childGenome, rad);
          let mutCount = 0;
          for(let g=0; g<5; g++) if(mutated[g] !== before[g]) mutCount++;
          births++;
          totalBorn++;
          avgMutationsPerBirth = lerp(avgMutationsPerBirth, mutCount, 0.06);

          const spawnDistance = c.r * EvoSimConfig.reproduction.spawnRadius;
          const child = new Cell(
            clamp(c.x + rand(-spawnDistance, spawnDistance), 0, WORLD_W),
            clamp(c.y + rand(-spawnDistance, spawnDistance), 0, WORLD_H),
            mutated,
            c.generation + 1 // Increment generation counter for child
          );
          // inherit energy/health using config values
          const { energyInheritance, healthInheritance, healthInheritanceBase } = EvoSimConfig.reproduction;
          child.energy = c.energy * energyInheritance;
          child.health = clamp(c.health + rand(healthInheritance.min, healthInheritance.max), 
                              healthInheritanceBase.min, healthInheritanceBase.max);

          // Infectivity threshold triggers timer (PRD spec: >3)
          if(child.genome[4] > 3) child.infect(child.genome[4]);

          newborns.push(child);
        }
      }
    }

    // Remove dead prey marked by predators (second pass is cheap)
    for(let i=cells.length-1; i>=0; i--){
      if(cells[i].health <= 0){
        const c = cells[i];
        // Enhanced resource recycling for predation victims
        recycleDeadCell(c);
        cells[i] = cells[cells.length-1];
        cells.pop();
      }
    }

    // Add newborns
    if(newborns.length){
      // cap hard
      const room = Math.max(0, Math.floor(MAX_CELLS_SOFT*1.8 - cells.length));
      for(let i=0; i<Math.min(room, newborns.length); i++) cells.push(newborns[i]);
    }

    // Keep food under cap - prioritize keeping recycled resources
    if(food.length > FOOD_CAP){
      // Remove environmental food first, keep recycled food
      const toRemove = food.length - FOOD_CAP;
      let removed = 0;
      
      // First pass: remove non-recycled food
      for (let i = food.length - 1; i >= 0 && removed < toRemove; i--) {
        if (!food[i].recycled && !food[i].persistent) {
          food.splice(i, 1);
          removed++;
        }
      }
      
      // Second pass: if still over cap, remove oldest environmental food first (preserve recycled)
      if (food.length > FOOD_CAP) {
        const stillToRemove = food.length - FOOD_CAP;
        // Sort environmental food (no deathTime) first, then recycled food by age
        food.sort((a, b) => {
          const aIsEnv = !a.deathTime;
          const bIsEnv = !b.deathTime;
          if (aIsEnv && !bIsEnv) return -1; // Environmental food comes first
          if (!aIsEnv && bIsEnv) return 1;  // Recycled food comes second
          return (a.deathTime || 0) - (b.deathTime || 0); // Among same type, sort by age
        });
        food.splice(0, stillToRemove); // Remove oldest (environmental first)
      }
    }

    // Update generation every 1000 births
    if (births > 0 && births % 100 === 0) {
      generation++;
      updateGenerationData();
      updateSpeciesDatabase();
    }
    
    // Update species database every 30 frames for real-time tracking
    if (performance.now() % 500 < 16) { // Roughly every 500ms
      updateSpeciesDatabase();
    }
    
    // Enhanced HUD
    el.hudCells.textContent = String(cells.length);
    el.hudFood.textContent = String(food.length);
    el.hudGeneration.textContent = String(generation);
    el.hudSpecies.textContent = String(speciesCount);
    
    // Calculate current average fitness
    let currentFitness = 0;
    if (cells.length > 0) {
      currentFitness = cells.reduce((sum, cell) => sum + calculateFitness(cell), 0) / cells.length;
    }
    el.hudFitness.textContent = currentFitness.toFixed(1);
    
    const anyPlague = cells.some(c => c.infected);
    el.hudPlague.textContent = anyPlague ? "on" : "off";
    
    // Track peak population and extinction events
    if (cells.length > peakPopulation) {
      peakPopulation = cells.length;
    }
    
    // Detect extinction events (population drops to very low levels)
    if (cells.length <= 5 && peakPopulation > 50) {
      extinctionEvents++;
      peakPopulation = cells.length; // Reset peak after extinction
    }
    
    // Update ecosystem stats panel (less frequently when performance is poor)
    if (renderFrameCount % (currentFPS < 30 ? 3 : 1) === 0) {
      updateEcosystemStats();
    }
    
    // Random ecosystem events
    if (Math.random() < 0.0001 && cells.length > 50) { // Very rare events
      triggerEcosystemEvent();
    }

    // Adaptive rendering based on performance
    const shouldRender = currentFPS > 30 || renderFrameCount % 2 === 0; // Skip every other frame if FPS drops
    const totalObjects = cells.length + food.length;
    
    if (shouldRender && totalObjects < EvoSimConfig.performance.maxRenderObjects) {
      draw(temp, stability, rad, dt);
    } else if (renderFrameCount % 3 === 0) { // Render every 3rd frame when performance is poor
      draw(temp, stability, rad, dt);
    }
    
    requestAnimationFrame(step);
    
    } catch (error) {
      console.error('Simulation error:', error);
      console.log('Cells:', cells.length, 'Food:', food.length);
      // Try to continue simulation after error
      setTimeout(() => requestAnimationFrame(step), 100);
    }
  }

  function draw(temp, stability, rad, dt){
    // Clear canvas first
    ctx.clearRect(0, 0, W, H);
    
    // Save context and apply zoom/viewport transform
    ctx.save();
    ctx.translate(W/2, H/2);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-WORLD_W/2 + viewportX, -WORLD_H/2 + viewportY);
    
    // Calculate visible area for culling (with generous margin for smooth scrolling)
    const margin = 200; // Generous margin to prevent pop-in
    const viewWidthHalf = W / (2 * zoomLevel);
    const viewHeightHalf = H / (2 * zoomLevel);
    
    // Calculate actual visible bounds in world coordinates
    // The viewport transform is: translate(-WORLD_W/2 + viewportX, -WORLD_H/2 + viewportY)
    // So visible area in world coords is:
    const visibleLeft = (WORLD_W / 2) - viewportX - viewWidthHalf - margin;
    const visibleRight = (WORLD_W / 2) - viewportX + viewWidthHalf + margin;
    const visibleTop = (WORLD_H / 2) - viewportY - viewHeightHalf - margin;
    const visibleBottom = (WORLD_H / 2) - viewportY + viewHeightHalf + margin;
    
    // Background: temperature tint + subtle noise
    const t = temp / 100;
    const bgHue = lerp(220, 12, t);
    ctx.fillStyle = hsl(bgHue, 40, 7, 1);
    ctx.fillRect(0,0,WORLD_W,WORLD_H);
    
    // Draw parameter zones if scattering is enabled
    if (parameterMap && parameterMap.zones.length > 1) {
      drawParameterZones();
    }

    // Subtle vignette
    const grd = ctx.createRadialGradient(WORLD_W*0.5,WORLD_H*0.5, Math.min(WORLD_W,WORLD_H)*0.1, WORLD_W*0.5,WORLD_H*0.5, Math.max(WORLD_W,WORLD_H)*0.65);
    grd.addColorStop(0, 'rgba(0,0,0,0)');
    grd.addColorStop(1, 'rgba(0,0,0,0.55)');
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,WORLD_W,WORLD_H);

    // Food with enhanced visuals for recycled resources (viewport culled)
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    let renderedFood = 0;
    for(const f of food){
      // Viewport culling for food
      if(f.x < visibleLeft || f.x > visibleRight || f.y < visibleTop || f.y > visibleBottom) {
        continue;
      }
      renderedFood++;
      // Optimized food visuals (reduced shadow effects for performance)
      if(f.recycled){
        // Fresh carrion - simplified rendering
        if(f.fresh){
          ctx.fillStyle = `rgba(251,146,60,${0.9*f.a})`; // Bright orange color
          ctx.beginPath();
          ctx.arc(f.x, f.y, 3.6*DPR, 0, Math.PI*2); // Much larger (+28%)
          ctx.fill();
          
          // Simplified pulsing effect (no shadow)
          if(zoomLevel > 0.7) { // Only show pulse when zoomed in
            const pulseTime = (performance.now() - (f.deathTime || 0)) / 1000;
            const pulse = 0.8 + 0.2 * Math.sin(pulseTime * 4);
            ctx.save();
            ctx.globalAlpha = pulse * 0.4;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(f.x, f.y, 4.0*DPR, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
          }
        } else {
          // Regular recycled food - no shadow
          ctx.fillStyle = `rgba(234,179,8,${0.8*f.a})`; // Bright yellow-green color
          ctx.beginPath();
          ctx.arc(f.x, f.y, 3.0*DPR, 0, Math.PI*2); // Larger (+36%)
          ctx.fill();
        }
      } else {
        // Regular environmental food (standard cyan)
        ctx.fillStyle = `rgba(94,234,212,${0.35*f.a})`;
        ctx.beginPath();
        ctx.arc(f.x, f.y, 2.4*DPR, 0, Math.PI*2); // Increased from 1.6 to 2.4 (+50%)
        ctx.fill();
      }
    }
    ctx.restore();

    // Cells (viewport culled and performance optimized)
    const normal = [];
    const glowy = [];
    let renderedCells = 0;
    
    for(const c of cells){
      // Viewport culling for cells
      const cellRadius = c.r + 20; // Include glow radius in culling
      if(c.x + cellRadius < visibleLeft || c.x - cellRadius > visibleRight || 
         c.y + cellRadius < visibleTop || c.y - cellRadius > visibleBottom) {
        continue;
      }
      
      renderedCells++;
      const effectiveAgg = c.genome[3] * EvoSimConfig.genetics.aggressivityGlowScale;
      if(effectiveAgg >= 8.75) glowy.push(c); // Half of max scaled range (17.5/2)
      else normal.push(c);
    }
    for(const group of [normal, glowy]){
      for(const c of group){
        const fert = c.genome[0];
        const res  = c.genome[1];
        const eff  = c.genome[2];
        const agg  = c.genome[3];
        const inf  = c.genome[4];

        const r = c.r;
        const sides = fertilityToSides(fert);

        // Brightness from aggressivity (3-bit with config scaling)
        const effectiveAgg = agg * EvoSimConfig.genetics.aggressivityGlowScale;
        const bright = lerp(0.45, 1.2, effectiveAgg/17.5);
        const fill = resistanceColor(res, bright);

        // Optimized glow for aggressivity (only for high-aggression cells)
        const glow = effectiveAgg/17.5;
        const shouldGlow = glow > 0.45 && zoomLevel > 0.5; // Skip glow when zoomed out
        if(shouldGlow){ 
          ctx.save();
          ctx.shadowColor = fill;
          ctx.shadowBlur = Math.min(12*DPR, lerp(0, 18*DPR, glow)); // Cap blur for performance
        }

        // Body - Always render as circle for performance, fertility affects border style
        ctx.fillStyle = fill;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.lineWidth = 1*DPR;

        // Draw circle (much faster than polygons)
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.fill();
        
        // Fertility affects border pattern instead of shape
        if(fert > 0) {
          // Higher fertility = more complex border pattern
          const segments = Math.min(fert + 2, 8); // 2-8 segments based on fertility
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.lineWidth = 0.8*DPR;
          for(let i = 0; i < segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x1 = c.x + Math.cos(angle) * (r - 1);
            const y1 = c.y + Math.sin(angle) * (r - 1);
            const x2 = c.x + Math.cos(angle) * (r + 1);
            const y2 = c.y + Math.sin(angle) * (r + 1);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
          }
          ctx.restore();
        }
        
        // Standard border
        ctx.beginPath();
        ctx.arc(c.x, c.y, r, 0, Math.PI*2);
        ctx.stroke();

        // Infectivity indicator: ring radius
        if(inf > 0){
          const spreadR = PLAGUE_SPREAD_BASE + inf*PLAGUE_SPREAD_PER;
          ctx.save();
          ctx.globalAlpha = 0.10 + 0.06*(inf/7); // 3-bit infectivity scaling
          ctx.strokeStyle = inf > 3 ? 'rgba(251,113,133,0.9)' : 'rgba(251,191,36,0.8)';
          ctx.lineWidth = 1*DPR;
          ctx.beginPath();
          ctx.arc(c.x, c.y, spreadR, 0, Math.PI*2);
          ctx.stroke();
          ctx.restore();
        }

        // Health bar (tiny) + plague timer
        const hp = clamp(c.health/100, 0, 1);
        const barW = (r*2.0);
        const barH = 2.2*DPR;
        const bx = c.x - barW/2, by = c.y + r + 4*DPR;
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(bx, by, barW, barH);
        ctx.fillStyle = hp > 0.5 ? 'rgba(94,234,212,0.85)' : 'rgba(251,113,133,0.9)';
        ctx.fillRect(bx, by, barW*hp, barH);

        if(c.infected){
          const p = clamp(c.plagueT / PLAGUE_TIMER_BASE, 0, 1);
          ctx.fillStyle = 'rgba(251,113,133,0.9)';
          ctx.fillRect(bx, by + barH + 2*DPR, barW * p, 1.8*DPR);
        }
        
        // Generation counter - display at the end of the cell
        if(c.generation > 0) {
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.font = `${Math.max(8, r * 0.4)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const genY = c.infected ? by + barH + 6*DPR + 8*DPR : by + barH + 8*DPR;
          ctx.fillText(`G${c.generation}`, c.x, genY);
        }
        
        ctx.restore();

        if(shouldGlow) ctx.restore();
      }
    }

    // Optimized radiation overlay (only in visible area)
    if(rad > 0 && zoomLevel > 0.3){
      ctx.save();
      ctx.globalAlpha = 0.04 + 0.06*(rad/15);
      ctx.fillStyle = 'rgba(251,191,36,1)';
      const particleCount = EvoSimConfig.performance.radiationParticleCount;
      for(let i=0;i<particleCount;i++){
        // Only spawn particles in visible area
        const x = rand(Math.max(0, visibleLeft), Math.min(WORLD_W, visibleRight));
        const y = rand(Math.max(0, visibleTop), Math.min(WORLD_H, visibleBottom));
        ctx.fillRect(x,y,1*DPR,1*DPR);
      }
      ctx.restore();
    }

    // Temperature "green zone" hint in world (very subtle)
    // This is visual-only; the actual matching is temp->idealRes.
    ctx.save();
    const gz = (temp >= 35 && temp <= 65);
    ctx.globalAlpha = gz ? 0.06 : 0.03;
    ctx.strokeStyle = gz ? 'rgba(34,197,94,1)' : 'rgba(148,163,184,1)';
    ctx.lineWidth = 2*DPR;
    ctx.strokeRect(8*DPR, 8*DPR, WORLD_W-16*DPR, WORLD_H-16*DPR);
    ctx.restore();
    
    // Restore context (remove zoom transform)
    ctx.restore();
    
    // Update minimap
    updateMinimap();
  }
  
  function drawParameterZones() {
    if (!parameterMap) return;
    
    const { gridSize, zones } = parameterMap;
    const zoneWidth = WORLD_W / gridSize;
    const zoneHeight = WORLD_H / gridSize;
    
    ctx.save();
    ctx.globalAlpha = 0.25; // Increased opacity for better visibility
    
    // Create gradient overlay for each zone
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const idx = y * gridSize + x;
        const zone = zones[idx];
        
        const zoneX = x * zoneWidth;
        const zoneY = y * zoneHeight;
        
        // Create radial gradient for each zone
        const centerX = zoneX + zoneWidth / 2;
        const centerY = zoneY + zoneHeight / 2;
        const radius = Math.min(zoneWidth, zoneHeight) * 0.7;
        
        const gradient = ctx.createRadialGradient(
          centerX, centerY, 0,
          centerX, centerY, radius
        );
        
        // Enhanced temperature-focused zone coloring
        const tempIntensity = zone.temp / 100;
        const resourceIntensity = zone.resources / 1000; // Updated for new max range
        const stabilityIntensity = zone.stability / 100;
        const radIntensity = zone.rad / 8;
        
        // Temperature-dominant color scheme: Blue (cold) ‚Üí Green (moderate) ‚Üí Red (hot)
        let r, g, b;
        if (tempIntensity < 0.5) {
          // Cold zones: Blue to Green (0-50¬∞C)
          const coldFactor = tempIntensity * 2; // 0-1 range
          r = Math.floor(20 + 60 * resourceIntensity); // Subtle resource influence
          g = Math.floor(100 + 155 * coldFactor); // Blue to green transition
          b = Math.floor(255 - 100 * coldFactor); // Strong blue fading to moderate
        } else {
          // Hot zones: Green to Red (50-100¬∞C)
          const hotFactor = (tempIntensity - 0.5) * 2; // 0-1 range
          r = Math.floor(100 + 155 * hotFactor); // Green to red transition
          g = Math.floor(255 - 100 * hotFactor); // Strong green fading
          b = Math.floor(20 + 60 * stabilityIntensity); // Subtle stability influence
        }
        
        // Add radiation overlay (yellow tint for high radiation)
        if (radIntensity > 0.3) {
          r = Math.min(255, r + Math.floor(80 * radIntensity));
          g = Math.min(255, g + Math.floor(60 * radIntensity));
        }
        
        // Create stronger gradient for better visibility
        gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.6)`); // Increased opacity
        gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.4)`); // More visible mid-range
        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0.1)`); // Softer edges
        
        ctx.fillStyle = gradient;
        ctx.fillRect(zoneX, zoneY, zoneWidth, zoneHeight);
        
        // Add temperature-based borders for better zone distinction
        if (gridSize > 1) {
          ctx.save();
          
          // Border color based on temperature
          if (tempIntensity < 0.3) {
            ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)'; // Blue for cold zones
          } else if (tempIntensity > 0.7) {
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)'; // Red for hot zones
          } else {
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)'; // Green for moderate zones
          }
          
          ctx.lineWidth = 1.5;
          ctx.strokeRect(zoneX, zoneY, zoneWidth, zoneHeight);
          
          // Add temperature indicator in zone center
          ctx.fillStyle = ctx.strokeStyle;
          ctx.font = `${Math.max(12, Math.min(zoneWidth, zoneHeight) * 0.15)}px monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(`${Math.round(zone.temp)}¬∞`, centerX, centerY);
          
          ctx.restore();
        }
      }
    }
    
    ctx.restore();
  }

  // drawShape function removed - now using circles for performance

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
